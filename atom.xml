<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greydoveh.github.io</id>
    <title>鸽子屋</title>
    <updated>2022-03-17T13:00:35.918Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greydoveh.github.io"/>
    <link rel="self" href="https://greydoveh.github.io/atom.xml"/>
    <subtitle>咕咕咕</subtitle>
    <logo>https://greydoveh.github.io/images/avatar.png</logo>
    <icon>https://greydoveh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 鸽子屋</rights>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 泛型]]></title>
        <id>https://greydoveh.github.io/post/CS-Generic/</id>
        <link href="https://greydoveh.github.io/post/CS-Generic/">
        </link>
        <updated>2022-03-17T12:57:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="泛型">泛型</h1>
<ol>
<li>泛型概述
<ul>
<li>提供了一种让多个类型共享一组代码的方式，允许声明类型参数化的代码，可以用不同的类型进行实例化</li>
<li>泛型类型不是类型，是类型的模板</li>
<li>五种泛型（注意前四个是类型，方法是成员）
<ul>
<li>类</li>
<li>结构</li>
<li>接口</li>
<li>委托</li>
<li>方法</li>
</ul>
</li>
<li>在类名后面放置<code>&lt;T&gt;</code>，然后在类中使用类型占位符<code>T</code>替换掉原本的类型，结果就是泛型类声明</li>
</ul>
</li>
<li>泛型类
<ul>
<li>声明类和创建类的实例</li>
<li>泛型不是类而是类的模板，所以必须先从它们构建实际的类类型</li>
<li>步骤
<ul>
<li>在某些类型上使用占位符来声明一个类</li>
<li>为占位符提供<strong>真实类型</strong>，这样就有了真实类的定义，该类型称为<strong>构造类型</strong></li>
<li>创建构造类型的实例</li>
</ul>
</li>
</ul>
</li>
<li>声明泛型类
<ul>
<li>在类型后面放置一组尖括号</li>
<li>尖括号中用逗号分隔的占位符字符串来表示希望提供的类型，这叫做<strong>类型参数</strong></li>
<li>在泛型类声明中使用类型参数来表示应该替代的类型</li>
</ul>
</li>
<li>创建构造类型
<ul>
<li>告诉编译器能使用哪些真实类型来替代类型参数，编译器获得真实类型并创建构造类型用来创造真实类对象的模板</li>
<li>要替代类型参数的真是类型叫做<strong>类型实参</strong></li>
</ul>
</li>
<li>创建变量和实例
<ul>
<li>非泛型
<ul>
<li>源代码大小：更大，需要为每一中类编写一个新的实现</li>
<li>可执行大小：无论每一个版本都会被使用，都会在编译的版本中出现</li>
<li>写的难易度：易于书写，因为它更具体</li>
<li>维护的难易度：更容易出问题，因为所有的修改需要用到</li>
</ul>
</li>
<li>泛型
<ul>
<li>源代码大小：更小，不管构造类型数量有多少，只需要一个实现</li>
<li>可执行大小：可执行文件中只会出现有构造类型的类型</li>
<li>写的难易度：比较难写，因为它更抽象</li>
<li>维护的难易度：易于维护，因为它只需要修改一个地方</li>
</ul>
</li>
</ul>
</li>
<li>类型参数的约束
<ul>
<li>所有的对象最终从object继承，泛型类只能确定这些参数类型实现了object的成员，如果代码尝试使用其他成员，编译器会产生一个错误信息</li>
<li>要让泛型变得更有用，需要提供额外信息让编译器知道参数可以接受哪些类型来产生构造类型</li>
<li>符合约束的类型参数叫做<strong>未绑定的类型参数</strong></li>
<li>where子句：约束使用where子句列出
<ul>
<li>每一个有约束的类型参数都有自己的where子句</li>
<li>如果形参有多个约束，它们的where子句使用逗号分隔</li>
<li>语法：<code>where TypeParam : constraint1, constraint2, ...</code></li>
</ul>
</li>
<li>有关where子句的要点：
<ul>
<li>它们在类型参数列表关闭的尖括号之后列出</li>
<li>它们不使用逗号或其他符号分隔</li>
<li>它们可以以任何次序列出</li>
<li>where是上下文关键字，所以可以在其他上下文中使用，即<em>在其他地方可以用where作为变量名等</em></li>
<li>
<pre><code class="language-csharp">class MyClass&lt;T1, T2, T3&gt; where T2 : Customer where T3 : IComparable {
    // ...
}
// 一个 where子句 只能写一个类型，但是可以有多条限制，顺序有要求下面讲
// 多个 where子句 之间，不用分隔符，顺序任意
</code></pre>
</li>
</ul>
</li>
<li>约束类型
<ul>
<li>类名：只有这个类型的类或子类才能作类型实参</li>
<li>class：任何引用类型，包括类、数组、委托和接口都可以用作类型实参</li>
<li>struct：任何值类型可以用作实参</li>
<li>接口名：只有这个接口或实现这个接口的类型才能用作类型实参</li>
<li>new()：任何带有无参公共构造函数的类型都可以用作实参，这叫做<strong>构造函数约束</strong></li>
</ul>
</li>
<li>约束的次序
<ul>
<li>最多只能有一个主约束（类名、class、struct），如果有则必须放在第一位</li>
<li>可以有任意多的接口名约束</li>
<li>如果有构造函数约束，则必须放在最后</li>
</ul>
</li>
</ul>
</li>
<li>泛型方法
<ul>
<li>与其他泛型不一样，泛型方法是成员不是类型，可以在非泛型类中声明</li>
<li>声明泛型方法
<ul>
<li>方法名称之后和方法参数列表之前放置类型参数列表</li>
<li>在方法参数列表后放置可选的约束子句</li>
<li>返回值可以是泛型类型</li>
</ul>
</li>
<li>调用泛型方法
<ul>
<li>提供类型实参</li>
</ul>
</li>
<li>推断类型
<ul>
<li>有时可以从方法参数中推断出泛型方法的类型形参用到的类型</li>
<li>如对于方法<code>public void MyMethod&lt;T&gt; (T myVal) { ... }</code></li>
<li>实际调用时可以写<code>MyMethod&lt;int&gt;(5)</code>，也可以省略方法形参直接写<code>MyMethod(5)</code></li>
<li>除了相同类型时，其他有用到T的也可以推断，如类型参数是<code>T</code>但参数是<code>T[]</code></li>
</ul>
</li>
<li>扩展方法和泛型类
<ul>
<li>扩展方法（静态方法，第一个参数使用this修饰）可以和泛型类结合使用</li>
<li>泛型类的扩展方法
<ul>
<li>必须声明为static</li>
<li>必须是静态类成员</li>
<li>第一个参数必须有关键字this</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>泛型结构
<ul>
<li>泛型结构的规则和条件与泛型类是一样的</li>
</ul>
</li>
<li>泛型委托
<ul>
<li>在委托类型名称和委托参数列表之间加上尖括号放置类型参数列表</li>
<li>在方法参数列表后面添加约束子句</li>
</ul>
</li>
<li>泛型接口
<ul>
<li>声明类似泛型类</li>
<li>实现接口的时候可以用泛型类的类型参数作为泛型接口的类型实参
<ul>
<li>
<pre><code class="language-csharp">interface IB&lt;T&gt; {
    // ...
}
class A&lt;S&gt; : IB&lt;S&gt; {
    // ...
}
</code></pre>
</li>
<li>可以在非泛型类中实现泛型接口</li>
<li>实现不同类型参数的泛型接口是不同的接口，如<code>A</code>可以同时实现<code>IB&lt;string&gt;</code>和<code>IB&lt;int&gt;</code>，但实现具体类型不能再使用泛型，如<code>A&lt;S&gt;</code>实现不能同时实现<code>IB&lt;int&gt;</code>和<code>IB&lt;S&gt;</code>，因为当S为int时存在潜在的冲突，但是泛型接口的名字不会和非泛型接口冲突</li>
</ul>
</li>
</ul>
</li>
<li>协变和逆变
<ul>
<li>可变性
<ul>
<li>协变、逆变、不变</li>
</ul>
</li>
<li>协变
<ul>
<li>原则上父类引用可以指向子类对象，但是对于泛型委托来说，如果一个泛型委托的类型参数只作为输出值，他只能指向相同类型参数的委托类型，而不能指向类型参数为子类的委托类型，即下面的代码会报错</li>
<li>
<pre><code class="language-csharp">class Animal { }
class Dog : Animal { }
delegate T Factory&lt;T&gt;();
class Program {
    static Dog MakeDog() {	return new Dog();	}
    static void Main() {
        Factory&lt;Dog&gt; dogMaker = MakeDog;
        Factory&lt;Animal&gt; animalMaker = dogMaker;	// 报错，因为两个委托之间不存在继承关系
    }
}
</code></pre>
</li>
<li>如果派生类只用于输出值，这种结构化的委托有效性之间的常数关系叫做<strong>协变</strong></li>
<li>为了让编译器知道这是我们的期望，则需要用<code>out</code>关键字标记委托声明中的类型参数</li>
<li>即将上面的代码修改为<code>delegate T Factory&lt;out T&gt;();</code>即可通过编译</li>
</ul>
</li>
<li>逆变
<ul>
<li>与上面的例子类似</li>
<li>期望传入基类时允许传入派生对象的特性叫<strong>逆变</strong></li>
<li>
<pre><code class="language-csharp">class Animal {  public int t = 10;   }
class Dog : Animal { }
delegate void Act&lt;in T&gt;(T t);
class Program {
    static void ActOnAnimal(Animal a) {
        System.Console.WriteLine(a.t);
    }
    static void Main() {
        Act&lt;Animal&gt; act = ActOnAnimal;
        Act&lt;Dog&gt;    dog = act;
        dog(new Dog());
    }
}
</code></pre>
</li>
<li>in为逆变关键字</li>
<li>如果类型参数只用作委托方法的输入参数，可以添加逆变关键字in，让两种不兼容但是理论上可行的类型可以成功赋值</li>
</ul>
</li>
<li>协变与逆变
<ul>
<li>协变
<ul>
<li><code>F&lt;out T&gt;()</code>类型的委托，类型变量是父类</li>
<li>实际构建委托时，使用子类的类型变量进行声明</li>
<li>在调用的时候，方法返回指向子类对象的引用</li>
</ul>
</li>
<li>逆变
<ul>
<li><code>F&lt;in T&gt;(T t)</code>类型的委托，类型参数是子类</li>
<li>实际构造委托时，使用父类类型进行声明</li>
<li>在调用的时候，方法传入子类的变量，参数的父类引用指向子类对象</li>
</ul>
</li>
</ul>
</li>
<li>接口的协变与逆变
<ul>
<li>接口除了应用到委托上，还可以应用到接口上</li>
<li>在泛型接口声明的时候，在泛型类型前加上协变/逆变关键字</li>
</ul>
</li>
<li>如果是返回类型和委托不匹配的方法去给委托赋值时，不需要添加out关键字，编译器会自动识别</li>
<li>但是如果刚刚的方法已经创建了委托并用该委托去给其他委托赋值时，就需要添加out关键字</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 转换]]></title>
        <id>https://greydoveh.github.io/post/CS-Convert/</id>
        <link href="https://greydoveh.github.io/post/CS-Convert/">
        </link>
        <updated>2022-03-15T12:53:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="转换">转换</h1>
<ol>
<li>转换
<ul>
<li>转换是接受一个类型的值并使用它作为另一个类型的等价值的过程</li>
<li>转换后的值应该和源值一样的，但其类型为目标类型</li>
</ul>
</li>
<li>隐式转换
<ul>
<li>零扩充：目标多出来的最高为都以0填充</li>
<li>符号扩充：额外的高位用源表达式的符号位填充</li>
</ul>
</li>
<li>显式转换和强制转换</li>
<li>转换的类型
<ul>
<li>转换
<ul>
<li>预定义的
<ul>
<li>数字
<ul>
<li>隐式</li>
<li>显式</li>
</ul>
</li>
<li>引用
<ul>
<li>隐式</li>
<li>显式</li>
</ul>
</li>
<li>拆箱/装箱</li>
</ul>
</li>
<li>用户自定义的
<ul>
<li>隐式</li>
<li>显式</li>
</ul>
</li>
</ul>
</li>
<li>除了标准转换，还可以为自定义类型定义隐式转换和显式转换
<ul>
<li>还有一个预定义的转换类型，叫做<strong>装箱</strong>，可以将任意类型转换为
<ul>
<li>object类型</li>
<li>System.ValueType类型</li>
</ul>
</li>
<li>拆箱可以将一个装箱的值转换为原始类型</li>
</ul>
</li>
</ul>
</li>
<li>数字的转换
<ul>
<li>隐式数字转换
<ul>
<li>如下关系存在隐式转换
<ul>
<li>byte：ushort、short</li>
<li>sbyte：short</li>
<li>char：ushort</li>
<li>ushort：uint、int</li>
<li>short：int</li>
<li>uint：ulong、long</li>
<li>int：long</li>
<li>ulong：float、decimal</li>
<li>long：float、decimal</li>
<li>float：double</li>
<li>double</li>
<li>decimal</li>
</ul>
</li>
<li>把上图看成有向图的邻接表，如果从A到B存在路径，则A可以隐式转换为B</li>
</ul>
</li>
<li>溢出检测上下文
<ul>
<li>C#提供了运行时检测结果移除的能力，通过<strong>checked</strong>和<strong>unchecked</strong>运算符实现</li>
<li>代码片段是否被检查称作溢出检测上下文
<ul>
<li>如果指定一个表达式或代码为checked，CLR会在转换产生<strong>溢出时抛出OverflowException</strong>异常</li>
<li>如果代码不是checked，转换会继续而不管是否产生溢出</li>
</ul>
</li>
<li>默认的溢出检测上下文是不检查</li>
<li>checked和unchecked运算符
<ul>
<li>表达式放在圆括号内并且不能是一个方法
<ul>
<li>checked(表达式)</li>
<li>unchecked(表达式)</li>
</ul>
</li>
<li>在unchecked上下文中会忽略溢出</li>
<li>在checked上下文中如果发生溢出会抛出OverflowException异常</li>
</ul>
</li>
<li>checked和unchecked语句
<ul>
<li>运算符用于表达式，而语句执行相同的功能，但是控制的是一段代码中的所有转换</li>
</ul>
</li>
</ul>
</li>
<li>显式数字转换
<ul>
<li>对于显式类型转换可能会发生数据丢失，知道<strong>数据发生丢失时会如何处理</strong>很重要</li>
<li>checked情况下溢出会抛出异常，下面介绍的是unchecked或者无修饰的不检查的情况</li>
<li>S：源类型，T：目标类型</li>
<li>整数类型到整数类型
<ul>
<li>S比T长？丢弃S中额外的最高位：符号扩展或零扩展S到T的长度</li>
</ul>
</li>
<li>float或double到整数类型
<ul>
<li>舍掉小数截断为最接近的整数</li>
<li>如果截断后不在T的范围内，属于C#的未定义行为，可以使用checked修饰并处理异常</li>
</ul>
</li>
<li>decimal到整数
<ul>
<li>如果结果不在T的范围内，则抛出OverflowException异常</li>
</ul>
</li>
<li>double到float
<ul>
<li>被舍入到最接近的float值</li>
<li>如果值太小不能用float表示，则设置为+0或-0</li>
<li>如果值太大不能用float表示，则设置为+INF或-INF</li>
</ul>
</li>
<li>float或double到decimal
<ul>
<li>如果值太小不能使用decimal表示则设置为0</li>
<li>如果值太大则会抛出溢出异常</li>
</ul>
</li>
<li>decimal到float或double
<ul>
<li>总会成功，但是可能损失精度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>引用转换
<ul>
<li>由引用保存的那部分信息是它执行的数据类型</li>
<li>引用转换接受源引用并返回一个指向堆中同一位置的引用，但是把引用标记为其他的类型</li>
<li>父类引用可以指向子类的对象
<ul>
<li>如果是父类引用指向子类对象，它看不到子类扩展父类的部分，即便是public</li>
<li>如果是子类重写的父类的方法，则用父类引用调用方法时调用的是子类重写的方法</li>
<li>但是如果子类是使用new屏蔽的方法，父类调用时依然是调用父类本身的方法</li>
</ul>
</li>
<li>隐式引用转换
<ul>
<li>任何引用类型可以隐式转换为object类型</li>
<li>任何类型可以隐式转换到它继承的接口</li>
<li>类可以隐式转换到
<ul>
<li>它继承链中的任何类</li>
<li>它实现的任何接口</li>
</ul>
</li>
<li>委托可以隐式转换成以下.NET BCL类和接口
<ul>
<li>System.Delegate、System.MulticastDelegate</li>
<li>System.ICloneable、System.Runtime.Serialization.ISerializable</li>
</ul>
</li>
<li>ArrayS数组，其中元素是Ts类型，可以隐式转换成
<ul>
<li>以下.NET BCL类和接口
<ul>
<li>System.Array</li>
<li>System.ICloneable</li>
<li>System.IList</li>
<li>System.ICollection</li>
<li>System.IEnumerable</li>
</ul>
</li>
<li>另一个数组ArrayT，其中元素类型Tt需要满足以下所有条件
<ul>
<li>两个数组有一样的维度</li>
<li>元素类型Ts和Tt都是引用类型</li>
<li>Ts和Tt直接存在隐式转换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>显式引用转换
<ul>
<li>显式转换包括
<ul>
<li>从object到任何引用类型</li>
<li>从基类型到继承它的类型</li>
</ul>
</li>
<li>倒转上述隐式转换的方向，可以使用显式引用转换</li>
<li>编译器允许引用在内存中不存在的类型，但是运行到强制转换时会抛出InvalidCastException异常</li>
<li>有效的显式引用转换
<ul>
<li>显式转换没必要。
<ul>
<li>存在隐式转换时，显式转换是有效的，但是和隐式转换执行相同的内容</li>
</ul>
</li>
<li>源引用是null。
<ul>
<li>null可以转换成引用类型，在运行到转换时虽然不会抛出InvalidCastException异常</li>
<li>但是后面如果试图访问会抛出NullReferenceException异常</li>
</ul>
</li>
<li>由源引用执行的实际数据可以被安全的进行隐式转换
<ul>
<li>如B是A的子类，一个A类引用实际指向B类对象，则把它转换为B类引用时是有效的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>装箱转换
<ul>
<li>装箱概述
<ul>
<li>包括值类型在内的所有C#类型都派生自object类型</li>
<li>值类型是轻量高效的类型，默认情况下堆上不包括它们的对象组件</li>
<li>如果需要使用对象组件，可以使用<strong>装箱</strong>（<em>boxing</em>）</li>
<li>装箱是一种隐式转换，它接收值类型的值，根据这个值在堆上创建一个完整的引用类型的对象并返回引用</li>
<li>
<pre><code class="language-csharp">int i = 10;
object oi = i;
</code></pre>
</li>
</ul>
</li>
<li>装箱是创建副本
<ul>
<li>在装箱后该值有两份副本，原始值类型和引用类型副本，每一个都可以独立操作</li>
</ul>
</li>
<li>装箱转换
<ul>
<li>任何值类型都可以被隐式转换为object类型、System.ValueType、InterfaveT（前提是实现了T接口）</li>
</ul>
</li>
</ul>
</li>
<li>拆箱转换
<ul>
<li><strong>拆箱</strong>（<em>unboxing</em>）是把装箱后的对象转换回值类型的过程</li>
<li>拆箱是显式转换</li>
<li>系统把值拆箱成T类型时执行了如下步骤：
<ul>
<li>它检查到要拆箱的对象实际是T的装箱值</li>
<li>它把对象的值复制到变量</li>
</ul>
</li>
<li>尝试将一个值拆箱为非原始类型时会抛出一个InvalidCastException异常</li>
</ul>
</li>
<li>用户自定义转换
<ul>
<li>用户可以为类和结构定义显式和隐式转换</li>
<li>
<pre><code class="language-csharp">public static implicit/explicit operator TargetType (SourceType Identifier) {
    // ... 
    return ObjectOfTargetType;
}
</code></pre>
</li>
<li>implicit是隐式转换，explicit是显式转换</li>
<li>用户自定义转换的约束
<ul>
<li>只可以为类或结构定义用户自定义转换</li>
<li>不能重定义标准隐式转换或显式转换</li>
<li>对于S和T如下命题为真
<ul>
<li>S和T是不同类型</li>
<li>S和T不能通过继承关联，也就是S不能继承自T，T也不能继承自S</li>
<li>S和T都不能是接口类型或者object类型</li>
<li>转换运算符必须是S或T的成员</li>
</ul>
</li>
</ul>
</li>
<li>评估用户自定义转换
<ul>
<li>目前讨论的自定义转换都是在单步内直接把源类型转换为目标类型</li>
<li>但是用户自定义转换在完整转换最多可以有3个步骤
<ul>
<li>预备标准转换</li>
<li>用户自定义转换</li>
<li>后续标准转换</li>
</ul>
</li>
<li>这个链中不可能有一个以上的用户自定义类型转换</li>
</ul>
</li>
<li>多步用户自定义转换的示例
<ul>
<li>Employee继承自Person，所以从Employee到Person存在标准转换</li>
<li>Person中包含一个int类型的age字段，从int到float有标准转换</li>
<li>Person中定义了从Person到int类中的隐式转换，返回age</li>
<li>Employee =&gt; Person =&gt; int =&gt; float</li>
<li>第一步为预备标准转换，第二步为用户自定义转换，第三步后续标准转换</li>
</ul>
</li>
</ul>
</li>
<li>is运算符
<ul>
<li>源表达式 is 目标类型，返回bool</li>
<li>如果源表达式可以通过以下方式成功转换为目标类型，运算符返回true
<ul>
<li>引用转换</li>
<li>装箱转换</li>
<li>拆箱转换</li>
</ul>
</li>
</ul>
</li>
<li>as运算符
<ul>
<li>类似于强转，只是不抛异常，转换失败会返回null</li>
<li>源表达式 as 目标类型，返回引用</li>
<li>由于as运算符返回引用表达式，它可以用作赋值表达式的源</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 接口]]></title>
        <id>https://greydoveh.github.io/post/CS-Interface/</id>
        <link href="https://greydoveh.github.io/post/CS-Interface/">
        </link>
        <updated>2022-03-14T12:49:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="接口">接口</h1>
<ol>
<li>接口使用示例（IComparable）
<ul>
<li>Array.Sort可以排序预定义类型的数组，对自定义类型排序会抛出异常</li>
<li>可以实现IComparable接口中的CompareTo方法后再使用排序</li>
<li>IComparable接口声明在BCL中，包含唯一的方法CompareTo</li>
<li>
<pre><code class="language-csharp">public interface IComparable {	// interface为接口定义的关键字
    int CompareTo(object obj);	// this &gt; obj返回+，&lt;-，=0
}
</code></pre>
</li>
<li>实现接口
<ul>
<li>在基类列表后面列出接口名称</li>
<li>必须为接口的每一个成员提供实现</li>
</ul>
</li>
<li>要使用Sort，如果仅声明CompareTo方法是不够的，还需要实现IComparable接口</li>
</ul>
</li>
<li>声明接口
<ul>
<li>重要事项
<ul>
<li>接口声明不能包含以下成员：
<ul>
<li>数据成员</li>
<li>静态成员</li>
</ul>
</li>
<li>接口声明只能包含如下类型的非静态成员函数的声明：
<ul>
<li>方法</li>
<li>属性</li>
<li>事件</li>
<li>索引器</li>
</ul>
</li>
<li>这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后使用分号</li>
<li>按照惯例，接口名称必须以大写的I开始</li>
<li>类似于分部类，接口也可以分隔成分部接口声明</li>
</ul>
</li>
<li>接口的访问性和接口成员的访问性
<ul>
<li>接口声明可以有任何的访问修饰符public、protected、internal或private</li>
<li>接口成员是隐式public的，不允许有任何访问修饰符包括public</li>
<li><strong>在类实现接口的方法的时候要显式写出public</strong></li>
<li>在类通过<strong>显式接口成员实现</strong>（即后面介绍的<code>接口名.方法名</code>）的时候不能写public</li>
</ul>
</li>
</ul>
</li>
<li>实现接口
<ul>
<li>重要事项
<ul>
<li>它必须实现接口的所有成员</li>
<li>如果类从基类继承并实现了接口，基类列表中的基类名称必须放在接口之前</li>
</ul>
</li>
</ul>
</li>
<li>接口是引用类型
<ul>
<li>不能通过类对象的成员访问接口，但是可以把对象强转为接口类型来获取指向接口的引用</li>
<li>可以通过点号调用接口的方法</li>
</ul>
</li>
<li>接口和as运算符
<ul>
<li>如果类对象没有实现接口，强转会抛异常</li>
<li>使用as运算符可以避免这个问题
<ul>
<li>如果实现了接口则返回接口的引用</li>
<li>没有实现接口则返回null而不是抛异常</li>
</ul>
</li>
<li>类对象引用 as 接口名</li>
</ul>
</li>
<li>实现多个接口
<ul>
<li>类可以实现任意数量的接口</li>
<li>基类与接口、接口与接口之间用逗号分隔</li>
</ul>
</li>
<li>实现具有重复成员的接口
<ul>
<li>如果一个类实现了多个接口并且其中一些接口有相同签名和返回类型的成员
<ul>
<li>那么类可以实现单个成员来满足所有包含重复成员的接口</li>
</ul>
</li>
<li>如果参数列表不同
<ul>
<li>可以都实现，作为方法重载</li>
</ul>
</li>
<li>如果参数列表相同但是返回类型不同
<ul>
<li>会报错，只能使用后面要讲的显式接口成员实现</li>
</ul>
</li>
</ul>
</li>
<li>多个接口的引用
<ul>
<li>对象引用可以强转为接口的引用，如果实现了多个接口，可以获取每个接口的独立引用</li>
</ul>
</li>
<li>派生成员作为实现
<ul>
<li>实现接口的类可以从它的基类继承实现的代码，即便基类没有实现该接口</li>
</ul>
</li>
<li>显式接口成员实现
<ul>
<li>单个类可以实现多个接口需要的成员，如6、7部分</li>
<li>也可以通过<strong>显式接口成员实现</strong>的方式为每一个接口分离实现，与显式接口成员实现相对的叫做<strong>类级别实现</strong></li>
<li>使用<strong>限定接口名称</strong>来声明，由<code>接口名称.成员名称</code>来实现</li>
<li>可以对多个接口中的重复成员提供不同的实现</li>
<li>类级别实现与显式接口成员实现（此处简称接口实现）的区别
<ul>
<li>类级别实现，方法是属于类的，而接口实现是属于接口的</li>
<li>类级别实现中，接口方法会指向类级别实现，而接口实现是包含了自己的代码</li>
<li>通过类级别实现，可以通过对象引用调用，可以在类内部直接调用，也可以通过接口引用去调用；而接口实现只能通过接口引用去调用</li>
<li>
<pre><code class="language-csharp">public interface II {
    int Fun();
}

class Test : II {
    int II.Fun() {  return 123; }
    public int Fun() {  return 456; }
}

        Test t = new Test();
        System.Console.WriteLine(t.Fun());	// 类级别实现，输出456
        II i = t as II;
        System.Console.WriteLine(i.Fun());	// 显式接口成员实现，输出123
</code></pre>
</li>
</ul>
</li>
<li>如果有显式接口成员实现，类级别是允许的，但不是必须的，有以下三种实现场景
<ul>
<li>类级别实现</li>
<li>显式接口成员实现</li>
<li>类级别和显式接口成员实现</li>
</ul>
</li>
<li>访问显式接口成员<strong>只能</strong>通过接口引用访问</li>
</ul>
</li>
<li>接口可以继承接口
<ul>
<li>接口本身可以从一个或多个接口继承</li>
<li>接口可以多继承
<ul>
<li>接口本身可以继承其他接口</li>
<li>结果接口包含它声明的所有接口和所有基接口的成员</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 委托、匿名方法、事件]]></title>
        <id>https://greydoveh.github.io/post/CS-Delegate-Lambda-Event/</id>
        <link href="https://greydoveh.github.io/post/CS-Delegate-Lambda-Event/">
        </link>
        <updated>2022-03-13T12:42:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c委托-匿名方法-事件">C#委托、匿名方法、事件</h1>
<h3 id="委托">委托</h3>
<ol>
<li>委托概述
<ul>
<li>委托是持有一个或多个方法的对象
<ul>
<li>可以理解成一个类型安全的、面向对象的函数指针</li>
</ul>
</li>
<li>委托可以包含多个方法，调用委托时，包含的每一个方法都会执行</li>
<li>可以把delegate看做一个包含有序方法列表的对象，这些方法具有相同的签名和返回类型
<ul>
<li>方法的列表被称为<strong>调用列表</strong></li>
<li>委托保存的方法可以来自任何类或者结构，可以是静态方法也可以是实例方法，只要它们在委托的返回类型以及委托的签名（包括<em>ref</em>和<em>out</em>修饰符）</li>
</ul>
</li>
</ul>
</li>
<li>声明委托类型
<ul>
<li>不一定需要在类内部声明，因为它是类型的声明</li>
</ul>
</li>
<li>创建委托对象
<ul>
<li>两种方式
<ul>
<li>可以使用new去创建委托，构造函数的参数即为方法名（<strong>注意不带括号</strong>）</li>
<li>可以使用快捷语法，在方法名称和其对应二点委托类型之间存在隐式转换，所以可以之间将方法名赋值给委托变量</li>
</ul>
</li>
<li>除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表</li>
</ul>
</li>
<li>组合委托
<ul>
<li>委托可以使用额外的运算符（+）来组合，这个运算最终会创建一个新委托，其调用列表连接了作为操作数的两个委托的调用列表副本</li>
<li>组合委托没有修改作为操作数的委托，<strong>委托是恒定的</strong>，委托对象被创建以后不能在被改变，委托的赋值是引用的赋值，让原来的引用指向了新的对象</li>
</ul>
</li>
<li>为委托添加方法
<ul>
<li>委托虽然是不变的，但是C#提供了看上去可以为委托添加方法的语句，即使用+=运算符</li>
<li>+=运算符后面可以加相同签名和返回类型的方法或者委托</li>
<li>使用+=时，仍然没有修改委托，同样是<strong>创建了一个新的委托</strong></li>
<li>可以为委托添加多个方法，每次添加都会在调用列表创建一个新的元素。</li>
</ul>
</li>
<li>从委托移除方法
<ul>
<li>可以使用-=从委托移除方法，同样是创建了一个新的委托</li>
<li>如果要移除的方法在调用列表里有多个实例，-=运算符会<strong>移除最后一个</strong>实例</li>
<li>如果委托中不存在要移除的方法，则没有效果</li>
<li>如果调用的委托为null，则会抛出异常</li>
<li>如果委托的调用列表为空，即为null，所以把所有方法移除后，委托会变成null</li>
</ul>
</li>
<li>调用委托
<ul>
<li>可以像调用方法一样调用委托</li>
<li>调用委托的参数将会用于委托中的所有方法</li>
<li>调用委托时中只会得到最后一个方法的返回值，其他的返回值均会被忽略，包括out修饰的返回值参数</li>
<li>如果委托中同一个方法出现多次，则每一次都会被调用</li>
<li>建议在调用委托前判断是否为空，或者使用另一种方式<code>del?.Invoke()</code></li>
</ul>
</li>
<li>调用带引用参数的委托
<ul>
<li>如果委托有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变</li>
<li>在调用委托列表的下一个方法时，参数的新值会传给下一个方法</li>
</ul>
</li>
</ol>
<h3 id="匿名方法">匿名方法</h3>
<ol>
<li>匿名方法概述
<ul>
<li>如果方法只用来初始化委托，没有必要创建独立的具名方法，可以使用匿名方法</li>
<li>匿名方法是在初始化委托时内联声明的方法</li>
</ul>
</li>
<li>使用匿名方法
<ul>
<li>声明委托时作为初始化表达式</li>
<li>组合委托时在赋值语句右边</li>
<li>为委托增加事件时在赋值语句右边</li>
</ul>
</li>
<li>匿名方法的语法
<ul>
<li>delegate关键字</li>
<li>参数列表，括号中包括参数类型和参数名，没有参数可以省略（圆括号也可以省略）</li>
<li>语句块，包含了匿名方法的代码</li>
<li>返回值
<ul>
<li>不需要显式写出返回类型，内部的返回值类型需要与委托匹配</li>
</ul>
</li>
<li>参数
<ul>
<li>除了数组参数，匿名方法的参数列表必须在以下三方面与委托匹配
<ul>
<li>参数数量</li>
<li>参数类型及位置</li>
<li>修饰符</li>
</ul>
</li>
<li>可以通过使圆括号为空或省略圆括号来简化匿名方法的参数列表，但是必须满足：
<ul>
<li>委托的参数列表不能包含任何out参数</li>
<li>匿名方法不使用任何参数</li>
</ul>
</li>
</ul>
</li>
<li>params参数
<ul>
<li>委托类型声明指定最后一个参数为params类型的参数</li>
<li>匿名方法参数列表忽略了params关键字</li>
</ul>
</li>
</ul>
</li>
<li>变量和参数的作用域
<ul>
<li>参数和方法内部变量的作用域被限制在匿名方法内</li>
<li>外部变量
<ul>
<li>外围作用域的变量叫做<strong>外部变量</strong></li>
<li>用在匿名方法实现代码中的外部变量称为<strong>被方法捕获</strong></li>
</ul>
</li>
<li>捕获变量的生命周期的扩展
<ul>
<li>只要捕获方法还是委托的一部分，即使变量离开了作用域，捕获的外部变量也会一直有效</li>
</ul>
</li>
</ul>
</li>
<li><strong>Lambda表达式</strong>
<ul>
<li>C#3.0引入的匿名方法的简化方式
<ul>
<li>删除delegate关键字</li>
<li>在参数列表和匿名方法主体之间</li>
</ul>
</li>
<li>进一步简化
<ul>
<li>省略参数的类型，只留下参数名
<ul>
<li>省略类型的参数列表称为隐式类型</li>
<li>带有参数的参数列表称为显式类型</li>
<li>要么都是显式类型，要么都是隐式类型</li>
</ul>
</li>
<li>如果只有一个参数并且是隐式类型，可以省略外围的圆括号</li>
<li>如果没有返回值类型且只有一条语句，可以省略花括号</li>
<li>如果方法体只有一句返回语句，可以省略花括号和return语句</li>
</ul>
</li>
<li>参数列表的要点
<ul>
<li>参数列表必须匹配</li>
<li>参数列表中的参数不一定需要包含类型（即隐式类型），除非委托有ref或out参数修饰，此时必须注明类型（即显式类型）</li>
<li>只有当只有一个参数且为隐式类型时，圆括号才能省略，否则必须有括号</li>
<li>如果没有参数，必须使用一组空的圆括号</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="事件">事件</h3>
<ol>
<li><strong>发布者/订阅者</strong>模式
<ul>
<li>发布者定义了一系列程序的其他部分可能感兴趣的事件</li>
<li>其他类可以注册，以便这些事件发生时发布者可以通知它们，这些订阅者类通过向发布者提供一个方法来<strong>注册</strong>以获取通知</li>
<li>当事件发生时，<strong>发布者触发事件，然后执行订阅者提交的所有事件</strong></li>
<li>由订阅者提供的方法称为<strong>回调方法</strong>，因为发布者通过执行这些方法来往回调用订阅者的方法。还可以将它们称为<strong>事件处理程序</strong>，因为它们是为处理事件而调用的代码</li>
</ul>
</li>
<li>事件概述
<ul>
<li>重要事项：
<ul>
<li>订阅者 <em>publisher</em>：发布某个事件的类或结构，其他类可以在该事件发生时得到通知</li>
<li>发布者 <em>subscriber</em>：注册并在事件发生时得到通知的类或结构</li>
<li>事件处理程序 <em>event handler</em>：由订阅者注册到事件的方法，在发布者触发事件时执行。事件处理程序方法可以定义在事件所在的类或结构中，也可以定义在不同的类或结构中</li>
<li>触发事件 <em>raise</em>：调用（<em>invoke</em>）或触发（<em>fire</em>）事件的术语。在事件触发时，所有注册到它的方法都会被依次调用</li>
</ul>
</li>
<li>实际上，事件就像是专门用于某种特殊用途的委托。事件包含了一个私有的委托
<ul>
<li>事件提供了对它的私有的控制委托的结构化访问，也就是说无法直接访问委托</li>
<li>事件中可用的操作比委托要少，只可以添加、删除或调用事件处理程序</li>
<li>事件被触发时，它调用委托来依次调用调用列表中的方法</li>
</ul>
</li>
</ul>
</li>
<li>声明事件
<ul>
<li>发布者必须提供事件对象。创建事件比较简单，只需要委托类型和名字。</li>
<li>声明事件的语法如下：
<ul>
<li>事件声明在一个类中</li>
<li>他需要委托类型的名称，任何附加到事件的处理程序都必须与委托类型的签名和返回类型匹配</li>
<li>它声明为public，这样其他类和结构可以在它上面注册事件处理程序</li>
<li>不能使用new来创建它的对象</li>
<li><code>public event EventHandler eventHandler;</code></li>
<li>其中<code>event</code>为关键字，<code>EventHandler</code>为委托类型，<code>eventHandler</code>为事件名</li>
<li>也可以生成为static</li>
</ul>
</li>
<li><strong>事件是成员</strong>，不是类型
<ul>
<li>和字段、方法一样，事件是类或结构的成员</li>
<li>不能在一段可执行代码中声明事件</li>
<li>他必须声明在类或结构中</li>
<li>被隐式自动初始化为null</li>
</ul>
</li>
<li>BCL声明了一个叫做EventHandler的委托，专门用于系统事件</li>
</ul>
</li>
<li>订阅事件
<ul>
<li>使用+=运算符来为事件增加事件处理程序，事件处理程序位于运算符右边</li>
<li>事件处理程序的规范可以是实例方法名、静态方法名、匿名方法、Lambda表达式</li>
</ul>
</li>
<li>标准事件的用法
<ul>
<li>程序事件的异步处理是C#事件的绝佳场景（如GUI编程中按钮点击、按下按键或系统定时器）</li>
<li>.NET框架提供了一个标准模式，即System命名空间声明的EventHandler委托类型</li>
<li>该类型的声明如下：<code>public delegate void EventHandler(object sender, EventArgs e);</code>
<ul>
<li>第一个参数用来保存触发事件的对象的引用</li>
<li>第二个参数用来保存状态信息</li>
<li>返回类型是void</li>
</ul>
</li>
<li>关于第二个参数EventArgs
<ul>
<li><strong>该参数不用于保存数据</strong>，它用于不需要传递数据的事件处理程序</li>
<li>如果希望传递数据，必须声明一个派生自EventArgs的类，用合适的字段保存需要传递的数据</li>
<li>目的是让EventArgs提供一个对所有事件和事件处理器都通用的签名</li>
</ul>
</li>
<li>一般传递参数
<ul>
<li>第一个参数可以使用this，第二个参数如果不传递数据可以使用null</li>
<li>如果要传递数据，需要使用EventArgs的派生类，并有对应版本的泛型委托，泛型的类型参数即为该派生类</li>
</ul>
</li>
</ul>
</li>
<li>移除事件处理程序
<ul>
<li>可以使用-=移除事件</li>
<li>如果注册了多次，则只移除列表中的最后一个实例</li>
</ul>
</li>
<li>事件访问器
<ul>
<li>可以通过为事件定义事件访问器改变+=和-=两个运算符的操作</li>
<li>两个访问器，add对应+=，remove对应-=</li>
<li>声明方式类似于属性</li>
<li>两个访问器都有value隐式值参数</li>
<li>如果使用访问器，则不包含内部委托对象，需要自己实现委托来进行事件注册，类似属性给出get和set的实现时需要手动绑定字段</li>
<li>两个访问器表现为void方法，不能使用包含返回值的return</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 数组]]></title>
        <id>https://greydoveh.github.io/post/CS-Array/</id>
        <link href="https://greydoveh.github.io/post/CS-Array/">
        </link>
        <updated>2022-03-09T12:36:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c数组">C#数组</h1>
<ul>
<li>
<p>数组是对象</p>
<ul>
<li>属性 Rank：
<ul>
<li>对于矩形数组，返回秩/维度，</li>
<li>对于交错数组，返回1</li>
</ul>
</li>
<li>属性 Length：
<ul>
<li>对于矩形数组，返回数组总长度（可以使用方法GetLength获取每一维的长度，参数从0开始代表最高维）</li>
<li>对于交错数组，返回最高维的维度长度</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本概念</p>
<ul>
<li>元素</li>
<li>秩/维度</li>
<li>维度长度：这一维的长度</li>
<li>数组长度：所有维度的长度之和</li>
</ul>
</li>
<li>
<p>多维数组</p>
<ul>
<li>矩阵数组
<ul>
<li>每行（以二维数组为例）的长度都一样</li>
<li>使用同一组中括号，用逗号（被称为秩说明符）隔开不同维度的长度/索引</li>
</ul>
</li>
<li>交错数组
<ul>
<li>数组的每个元素都是独立的数组</li>
<li>每行（以二维数组为例）长度可以不同</li>
<li>每一维都是用一个方括号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一维数组和矩形数组</p>
<ul>
<li>一维数组
<ul>
<li>声明： <code>int[] a;</code></li>
<li>实例化：<code>int[] a = new int[10];</code></li>
<li>初始化：<code>int[] a = new int[] {1, 2, 3};</code></li>
<li>省略new：<code>int[] a = {1, 2, 3};</code></li>
</ul>
</li>
<li>矩形数组
<ul>
<li>声明：<code>int[,] b;</code></li>
<li>实例化：<code>int[,] b = new int[3, 4];</code></li>
<li>初始化：<code>int[,] b = new int[,] { {1, 2}, {3, 4} };</code></li>
<li>省略new：<code>int[,] b = { {1, 2}, {3, 4} };</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>交错数组</p>
<ul>
<li>数组的数组</li>
<li>实例化时，只允许指定最高维的长度
<ul>
<li><code>int[][] a = new int [3][];</code>是可以的</li>
<li><code>int[][] a = new int [3][4];</code>是不允许的</li>
</ul>
</li>
<li>初始化时，每一行都要new</li>
<li>交错数组的某一维可以是矩形数组</li>
</ul>
</li>
<li>
<p>比较交错数组和矩形数组</p>
<ul>
<li>交错数组
<ul>
<li>多个数组对象</li>
<li>更复杂</li>
<li>有对一维数组的优化</li>
<li>foreach按层遍历</li>
</ul>
</li>
<li>矩形数组
<ul>
<li>一个数组对象</li>
<li>较简单</li>
<li>没有优化</li>
<li>foreach遍历所有元素</li>
</ul>
</li>
<li>在CIL中，一维数组有特点的指令用于性能优化，矩形数组没有这些指令，并且不在相同级别进行优化。</li>
<li>因此，有时使用一维数组（可以被优化）的交错数组比矩形数组（不能被优化）更有效率</li>
<li>另一方面，矩形数组的编程复杂度要小很多，因此它会被作为一个单元而不是数组的数组</li>
</ul>
</li>
<li>
<p>数组协变</p>
<ul>
<li>类似于Java中上转型对象</li>
<li>即对于父类引用的数组，每个元素对应的引用实际指向子类</li>
</ul>
</li>
<li>
<p>数组继承自System.Array类的属性方法</p>
<ul>
<li>属性
<ul>
<li>Rank： 实例属性，获取总维度数</li>
<li>Length：实例属性，获取数组中所有维度的元素总和</li>
</ul>
</li>
<li>方法
<ul>
<li>GetLength：实例方法，返回指定维度长度</li>
<li>Clear：静态方法，将某一范围内的元素值设置为0或null</li>
<li>Sort：静态方法，在一维数组中对数组进行排序</li>
<li>BinarySearch：静态方法，使用二分搜索一维数组中的值</li>
<li>Clone：实例方法，进行数组的浅复制</li>
<li>IndexOf：静态方法，返回一维数组中遇到的第一个值</li>
<li>Reverse：静态方法，反转数组某一范围的元素</li>
<li>GetUpperBound：实例方法，获取指定维度的上界（<strong>不同于C++中的STL</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 枚举]]></title>
        <id>https://greydoveh.github.io/post/CS-Enum/</id>
        <link href="https://greydoveh.github.io/post/CS-Enum/">
        </link>
        <updated>2022-03-07T12:38:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c枚举">C#枚举</h1>
<ul>
<li>
<p>值类型</p>
</li>
<li>
<p>设置底层类型和显式值</p>
<ul>
<li>
<pre><code class="language-csharp">enum Enum : ulong {	// 类似继承的方式设置底层类型，默认为int
    Green,			// 0
    Yellow = 10, 	// 10
    Red, 			// 11
}
</code></pre>
</li>
<li>
<p>每个枚举类型都有一个底层值，默认为int，第一个成员默认为0，后面比前面多1</p>
</li>
<li>
<p>如果给其中某个成员赋值，则再后面没有显式赋值的成员会继续在前面的基础上+1</p>
</li>
<li>
<p>如果显式值过大超出了int的范围，可以设置底层类型为long或者ulong，底层类型可以是任何整数类型</p>
</li>
<li>
<p>关联到成员名称的值不需要是独特的，如可以允许多个成员使用同样的值</p>
</li>
<li>
<p>也可以使用该枚举类型中的成员给其他成员赋值</p>
</li>
</ul>
</li>
<li>
<p>位标志</p>
<ul>
<li>
<p>标志变量的压缩，把多个标志变量压缩到同一个变量里表示，<em>类似C++中的 bitset？</em></p>
</li>
<li>
<p>可以通过或运算<code>|</code>来标志多个位</p>
</li>
<li>
<p>可以通过HasFlag判断该位是否被标记，如果是多个位可以对要判断的位相或</p>
</li>
<li>
<p>也可以通过&amp;来判断标记</p>
</li>
<li>
<pre><code class="language-csharp">[Flags]	// Flags特性
enum FlagsEnum {
    first = 0x01,
    second = 0x02,
    third = 0x04,
    forth = 0x08
}
    FlagsEnum flags = FlagsEnum.second | FlagsEnum.third;
    bool f1 = flags.HasFlag(FlagsEnum.second);
    bool f2 = flags.HasFlag(FlagsEnum.first | FlagsEnum.third);	// 注意逻辑，虽然后面是两个条件的相或，但是HasFlag本身是和与逻辑对应的，所以是两个标志位都检查的
    bool f3 = ((flags &amp; FlagsEnum.forth) == FlagsEnum.forth);
</code></pre>
</li>
<li>
<p>Flags特性</p>
<ul>
<li>虽然不改变计算结果，但是提供了一些方便的特性</li>
<li>首先是通知编译器、对象浏览器等，该枚举可以按位标志进行组合</li>
<li>其次是格式化输出
<ul>
<li>我们知道对于枚举类型，直接输出和ToString()均为返回字符串</li>
<li>但是对于上面代码中的flags这种经过或运算的值，如果不加Flags特性时输出为计算后的整数，因为在调用ToString时没有找到值为12对应的枚举成员的字符串，所以会输出整数12</li>
<li>加上Flags特性后，会将12对应两个分开的位标志成员，输出为两个字符串并用逗号和空格隔开</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>补充</p>
<ul>
<li>
<p>枚举只有单一的成员类型：声明的成员常量</p>
</li>
<li>
<p>不同枚举类型之间不能比较大小</p>
</li>
<li>
<p>枚举类型可以枚举</p>
<ul>
<li>
<pre><code class="language-csharp">enum MyEnum {
    first, second, third
}
for (MyEnum e = MyEnum.first; e &lt;= MyEnum.third; e++) {
    System.Console.WriteLine(e);
}
</code></pre>
</li>
<li>
<p>但是注意上面这段代码，如果在枚举声明时有赋值操作，则在遍历时会有中间没有声明的整数被枚举到</p>
</li>
</ul>
</li>
<li>
<p>Enum类型还包含一些静态方法，如GetNames、GetName、IsDefine等，多数都有泛型与非泛型两种使用方式，但是泛型的版本，如果有第二个参数的话必须是枚举，非泛型版本可以使用整数或字符串</p>
<ul>
<li>
<p>GetNames：参数为枚举的类型（Type），返回所有成员名称的字符串数组，泛型版本无参数</p>
</li>
<li>
<pre><code class="language-csharp">string[] myEnums = Enum.GetNames(typeof(MyEnum));	// 也可以使用Enum.GetNames&lt;MyEnum&gt;()
foreach (var myEnum in myEnums) {
    System.Console.WriteLine(myEnum);
}
</code></pre>
</li>
<li>
<p>GetName：参数为枚举的类型（Type）和整数，返回成员名称的字符串，如果不存在则返回null</p>
</li>
<li>
<p>IsDefined：参数为枚举的类型（Type）和整数或字符串，如果在枚举中定义了该项则返回true</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记 - 杂]]></title>
        <id>https://greydoveh.github.io/post/CS-sth/</id>
        <link href="https://greydoveh.github.io/post/CS-sth/">
        </link>
        <updated>2022-03-07T02:57:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c学习笔记-杂">C#学习笔记 - 杂</h1>
<blockquote>
<p>主要记录一些其他语言没有或用法不一样的新玩意</p>
<p>以及常用和重点内容</p>
<p>结合《C#图解教程（第4版）》学习</p>
</blockquote>
<p><strong>1. C#中的foreach循环</strong></p>
<ul>
<li>迭代变量是临时的而且是只读的</li>
<li>但对于引用类型的数据，引用是只读的，但是数据是可以修改的</li>
</ul>
<pre><code class="language-csharp">int[] nums = new int []{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
foreach (int item in nums) {
	Console.WriteLine(item);
}
</code></pre>
<p><strong>2. C#中的高维数组</strong></p>
<ul>
<li>C#中数组只能放在类型后，而不能放在变量名后</li>
<li>数组的长度不能写在类型声明的方括号中，只能写在实例化的方括号中</li>
</ul>
<pre><code class="language-csharp">// 1. 交错数组
int[][] matrix = new int [][] {		// 或者写[2][]，但是不能些[2][3]
    new int [] {1, 2, 3},			// 或者写[3]
    new int [] {4, 5, 6}
};
// 2. 矩形数组
int [,] matrix2 = new int [2, 3] {	// 或者写[,]，但是不能写[2,]或[,3]
    {1, 2, 3},
    {4, 5, 6}
};
</code></pre>
<p><strong>3. 参数数组，即任意个数参数</strong></p>
<pre><code class="language-csharp">void fun(params int[] nums) {
    // ... 
}
</code></pre>
<p><strong>4. 结构体</strong></p>
<ul>
<li>
<p>在C#结构体的构造函数</p>
<ul>
<li>
<p>构造函数必须对所有成员进行初始化</p>
</li>
<li>
<p>和类不同的是，给结构体提供了其他构造函数时，系统提供的默认构造函数仍然保留，如果再给定一个无参的构造函数会报错</p>
</li>
<li>
<p>但是如果通过默认参数的方式指定一种看上去无参的构造函数，仍然会调用系统的默认构造函数（基本类型都是默认值，引用类型都是null），如下面的例子，输出结果就是0</p>
</li>
<li>
<pre><code class="language-csharp">struct S {
    public int x;
    public S(int x = 20) {
        this.x = x;
    }
}
class Program {
    static void Main(string[] args) {
        S s = new S();
        System.Console.WriteLine(s.x);
    }  
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>和C++不同的是，C#中结构体的字段默认是private类型</p>
</li>
<li>
<p>C#中结构体字段不能直接初始化，要在构造函数中赋值</p>
</li>
<li>
<p>结构体类型为值类型，而非引用类型</p>
<ul>
<li>可以不使用new，但是class必须使用new</li>
<li>不能赋值为null，且不能引用同一对象，赋值为值拷贝</li>
</ul>
</li>
<li>
<p>结构体是密封的，不能被派生，也不能手动派生自其他类型（结构体隐式派生自ValueType），但是可以实现其他接口</p>
</li>
<li>
<p>如果想将结构实例作为引用类型对象，需要创建<em>装箱</em>。<em>装箱和拆箱</em> 放在后面解释</p>
</li>
<li>
<p>结构的开销小于类，但装箱拆箱代价较高</p>
</li>
<li>
<p>预定义简单类型被.NET实现为结构</p>
</li>
<li>
<p>可以声明分布结构类似分部类</p>
</li>
</ul>
<p><strong>5. 字符串及处理方法</strong></p>
<p><strong>6. 运算符重载</strong></p>
<ul>
<li>
<pre><code class="language-csharp">public static Type operator + (Type a, Type b) {
  // ...
}
</code></pre>
</li>
<li>
<p>只能用于class或struct</p>
</li>
<li>
<p>一元运算符要带一个class或struct类型的参数</p>
</li>
<li>
<p>二元运算符两个参数，其中至少一个为class或struct类型</p>
</li>
<li>
<p>同时使用public和static</p>
</li>
<li>
<p>作为要操作的类的成员</p>
</li>
<li>
<p>运算符重载限制</p>
<ul>
<li>不能创建新运算符，也不能修改运算符的语法规则用法</li>
<li>不能重载预定义类型的运算符</li>
<li>不能该改变运算符的优先级或者结合性</li>
</ul>
</li>
</ul>
<p><strong>7. 索引器</strong></p>
<ul>
<li>
<pre><code class="language-csharp">public Type this[Type param1, ...] {
    get { }
    set { }
}
</code></pre>
</li>
<li>
<p>不能声明为static</p>
</li>
<li>
<p>与属性一样同样有一个隐藏参数value</p>
</li>
<li>
<p>注意自己实现索引器时，尤其是访问数组和列表时<strong>要记得处理异常</strong></p>
</li>
<li>
<p>可以根据参数列表不同进行重载</p>
</li>
</ul>
<p><strong>8. dynamic类型</strong></p>
<ul>
<li>由于.NET框架中有动态类型语言如IronPython和IronRuby等，C#要使用这些语言的程序集时可以使用dynamic关键字</li>
</ul>
<p><strong>9. 预定义简单类型</strong></p>
<ul>
<li>sbyte、byte、short、ushort、int、uint、long、ulong：有符号/无符号  8、16、32、64位整数</li>
<li>float、double：单双精度浮点数</li>
<li>bool、char：布尔类型、字符类型</li>
<li>decimal：小数类型的有效数字精度为28位</li>
</ul>
<p><strong>10. 格式化字符串</strong></p>
<ul>
<li>C#中格式化字符串不使用%d，而是用花括号+数字（替代标记）</li>
</ul>
<p><strong>11. 访问修饰符</strong></p>
<ul>
<li>private：私有，不写默认为私有</li>
<li>public ：公有</li>
<li>protected：受保护的</li>
<li>internal：内部的，同一程序集内可以访问</li>
<li>protected internal：内部的或受保护的</li>
</ul>
<p><strong>12. ref和out</strong></p>
<ul>
<li>使用ref时，相当于传入指针或引用
<ul>
<li>对于引用类型的数据，ref相当于二级指针</li>
<li>如果不使用ref，在方法内部使用new时，不会同步到方法外，但是对象的内容会被修改</li>
<li>如果使用ref，对象的内容会被修改，同时引用的执行也可以被更改</li>
</ul>
</li>
<li>和ref不一样，ref对应引用，而out是输出返回用的
<ul>
<li>如果是out，则在函数内部不能读取到原来的值，使用前必须先给其赋值</li>
<li>在调用函数时可以没有初始值，而且初始值对方法来说无所谓因为在内部会被先修改</li>
</ul>
</li>
</ul>
<p><strong>13. 命名参数</strong></p>
<ul>
<li>
<p>可以在调用函数时，通过指定形参名的方式更改传参的顺序</p>
</li>
<li>
<p>虽然看上去没什么用，所以这里举一个例子</p>
</li>
<li>
<pre><code class="language-csharp">static void MyFunc(int a, int b = 456, int c = 789) {
    System.Console.WriteLine(&quot;{0}, {1}, {2}, &quot;, a, b, c);
}
static void Main(string[] args) {
    int[] nums = new int []{1, 2, 3};
    MyFunc(123, c: 2);
}   
</code></pre>
</li>
</ul>
<p><strong>14. 可选参数要放在参数数组即params前</strong></p>
<p><strong>15. 类中出了字段、方法以外还有属性，属于函数成员（执行代码）</strong></p>
<p><strong>16. 对象初始化语句</strong></p>
<ul>
<li>
<pre><code class="language-csharp">new MyCalss {x = 10, y = 20};
new MyCalss(10, 20) {x = 10, y = 20};
</code></pre>
</li>
<li>
<p>只能对public的成员使用</p>
</li>
<li>
<p>执行晚于构造函数</p>
</li>
<li>
<p>花括号内不加分号，花括号结束后要加毕竟是一条语句</p>
</li>
</ul>
<p><strong>17. readonly修饰符</strong></p>
<ul>
<li>与const的区别：
<ul>
<li>readonly可以在初始化时或构造函数内赋值，如果是static则要在静态构造函数里赋值</li>
<li>const在编译时决定，readonly在运行时决定，可以在不同情况下使用不同的值</li>
<li>const的行为是静态的不能用static修饰，但readonly可以是实例字段也可以是静态字段</li>
</ul>
</li>
</ul>
<p><strong>18. 访问器</strong></p>
<ul>
<li>默认情况下get和set和对应的属性/索引器有相同访问级别</li>
<li>可以给get和set分别添加访问级别，如get; private set;</li>
<li>只有get和set两个都出现时才能添加访问修饰符，而且只能有一个访问器能有访问修饰符</li>
<li>访问器的访问权限需要比对应的成员更加严格</li>
</ul>
<p><strong>19. 分部类</strong></p>
<ul>
<li>一个类拆成多个类来写，每一部分类名相同，都在前面加上partial修饰符</li>
<li>在WPF中，每个页面都会生成两个类文件，一个声明页面上的控件，一个可用于实现页面或表单组件的外观和行为</li>
</ul>
<p><strong>20. 分部方法</strong></p>
<ul>
<li>一个分部类给出声明，另一个分部类给出实现</li>
<li>两部分可以在同一个分部类中，也可以放在不同的分部类中</li>
<li>条件：
<ul>
<li>返回类型必须是void</li>
<li>方法的签名不包括访问修饰符，即隐式私有的</li>
<li>参数列表不能有out</li>
<li>两部分方法前都加上partial修饰符</li>
</ul>
</li>
<li>如果要用分部方法
<ul>
<li>可以有声明没有实现，这种情况下编译器会把方法的声明和方法内所有对方法的调用删除</li>
<li>不能只有实现没有声明</li>
</ul>
</li>
</ul>
<p><strong>21. 继承方法和父类方法同名时</strong></p>
<ul>
<li>不加关键词为直接覆盖，不推荐，会报警告</li>
<li>加关键词new为覆盖/屏蔽，此时如果用父类引用指向子类对象时，执行方法为父类方法</li>
<li>加关键词override为重写/覆写，此时如果用父类引用指向子类对象时，执行方法为子类方法
<ul>
<li>注意只有父类声明为virtual或abstract时，子类才允许重写</li>
</ul>
</li>
</ul>
<p><strong>22. 构造函数初始化语句</strong></p>
<ul>
<li>
<p>base：调用基类构造</p>
</li>
<li>
<pre><code class="language-csharp">class A {
    int x;
    A(int x = 0) {
        this.x = x;
    }
}
class B : A {
	int y;
    public B() : base() { }	// 等价于 public B() { }
    public B(int x, int y) : base(x) {
        this.y = y;
    }
}
</code></pre>
</li>
<li>
<p>this：提取当前类构造函数的公共部分</p>
</li>
<li>
<pre><code class="language-csharp">class Stu {
    readonly int id;
    readonly string name;
    float score;
    int x;
    private Stu(string name, int id) {
        this.name = name;
        this.id = id;
    }
    public Stu(string name, int id, float score) : this(name, id) {
        this.score = score;
    }
    public Stu(string name, int id, int x) : this(name, id) {
        this.x = x;
    }
}
</code></pre>
</li>
</ul>
<p><strong>23. 类访问修饰符</strong></p>
<ul>
<li>public：可以被任何程序集中的代码访问</li>
<li>internal：只能被自己所在的程序集内的类看到（类的默认访问级别）</li>
</ul>
<p><strong>24. 成员访问修饰符</strong></p>
<ul>
<li>public：任意程序集均可访问</li>
<li>private：仅自身类可以访问</li>
<li>protected：仅自身类以及子类可以访问</li>
<li>internal：相同程序集中的类均可访问</li>
<li>protected internal：相同程序集中可访问，其他程序集中继承自该类的类可访问，即protected和internal是相或的关系</li>
</ul>
<p><strong>25. 抽象类和抽象成员</strong></p>
<ul>
<li>抽象成员
<ul>
<li>只有函数成员可以声明为abstract，方法和访问器只写声明不写实现，加分号</li>
<li>抽象类中的方法、属性、事件、索引器可以声明为abstract</li>
<li>可以被继承重写且非抽象类中必须重写，但是不用而且不能声明为virtual，重写时使用override</li>
</ul>
</li>
<li>抽象类
<ul>
<li>用abstract修饰，不能实例化</li>
<li>可以包含抽象或非抽象的成员</li>
<li>抽象类继承抽象类可以不用重写抽象成员；非抽象类继承自抽象类必须重写所有抽象成员</li>
</ul>
</li>
</ul>
<p><strong>26. 密封类</strong></p>
<ul>
<li>被sealed修饰的类为密封类，密封类不能被继承</li>
<li>一个类不能同时被abstract和sealed修饰，因为一个要求必须继承重写另一个不能被继承</li>
<li>类似Java中的final类</li>
</ul>
<p><strong>27. 静态类</strong></p>
<ul>
<li>类本身需要被标记为static</li>
<li>成员必须是静态的，声明为static或const</li>
<li>可以有静态构造函数，但是不能实例化</li>
<li>不能被继承，是密封类（隐式密封类，不需要声明为sealed）</li>
<li>可以通过类名访问成员名</li>
<li>常用的Math类就是静态类</li>
</ul>
<p><strong>28. 扩展方法</strong></p>
<ul>
<li>
<p>通过在静态类中的公开静态方法中的第一个参数添加this，可以通过点去调用</p>
</li>
<li>
<pre><code class="language-csharp">public static class ExtendString {	// static
    public static int Find(this string s, string t) {	// public static	
        for (int i = 0; i &lt; s.Length; i++) {
            if (s[i] == t[0]) {
                bool f = true;
                for (int j = 0; j &lt; t.Length &amp;&amp; i + j &lt; s.Length; j++) {
                    if (s[i + j] != t[j]) {
                        f = false;  break;
                    }
                }
                if (f)
                    return i;
                }
            }
        }
        return -1;
    }
}

class Program {
    static void Main(string[] args) {
        string s = &quot;123&quot;, t = &quot;22&quot;;
        int id = s.Find(t);	// s.Find(t);
        System.Console.WriteLine(id);
    }      
}
</code></pre>
</li>
</ul>
<p><strong>29. 浮点数取余</strong></p>
<ul>
<li>在C#中可以对浮点数进行取余</li>
<li>运算规则：如2.0 % 1.5 = 0.5，2.5 % 1.5 = 1等</li>
</ul>
<p><strong>30. 类型转换的运算符重载</strong></p>
<ul>
<li>
<pre><code class="language-csharp">class LimitedInt {
    readonly int maxValue;
    readonly int minValue;
    private int value;
    public int Value {
        get {
            return value;
        } 
        set {
            this.value = value;
        }
    }
    public LimitedInt(int x, int max = int.MaxValue, int min = int.MinValue) {
        Value = x;
        maxValue = max;
        minValue = min;
    }
    // implicit为隐式转换，explicit为显式转换
    public static implicit operator int(LimitedInt limitedInt) {	// LimitedInt转换为int
        return limitedInt.Value;
    }
    public static implicit operator LimitedInt(int x) {		// int转换为LimitedInt
        return new LimitedInt(x);
    }
}

class Program {
    static void Main(string[] args) {
        LimitedInt limitedInt = 100;
        int x = limitedInt;
        System.Console.WriteLine(x);
    }  
}
</code></pre>
</li>
<li>
<p>如果声明了implicit隐式转换，也可以使用强制转换</p>
</li>
<li>
<p>但是如果只声明了explicit显式转换，则不能使用隐式转换，必须使用显式转换（强制转换）</p>
</li>
<li>
<p>两者不能同时声明</p>
</li>
</ul>
<p><strong>31. using语句</strong></p>
<ul>
<li>
<p>使用命名空间是using指令，不是using语句</p>
</li>
<li>
<p>资源是指实现了IDisposable接口的类或结构</p>
<ul>
<li>
<p>不适用using的情况下释放资源可以使用</p>
</li>
<li>
<pre><code class="language-csharp">Type t = new Type();	// 分配资源，其中Type必须实现IDisposable
// 使用资源
t.Dispose();	// 处置资源
</code></pre>
</li>
<li>
<p>但是如果在使用资源的时候发生了异常可能导致Dispose不会被调用，需要手动处理异常</p>
</li>
</ul>
</li>
<li>
<p>using语句可以尽快释放资源并确保这些资源被适当处置</p>
<ul>
<li>
<pre><code class="language-csharp">using (Type t = new Type()) {	// 分配资源，其中Type必须实现IDisposable
    // 使用资源
}	// 处置资源（隐式）
</code></pre>
</li>
<li>
<p>using会执行以下内容：</p>
<ul>
<li>分配资源</li>
<li>把使用资源的部分放入try块中</li>
<li>创建资源的Dispose方法的调用，并放进finally块中</li>
</ul>
</li>
<li>
<p>这样就方便了程序员不需要手动处理异常，还能确保资源得到适当的处置</p>
</li>
<li>
<p>using的小括号中可以用分配多个资源并用逗号隔开，并且using语句可以嵌套使用</p>
</li>
</ul>
</li>
<li>
<p>using还有另外一种形式</p>
<ul>
<li>
<pre><code class="language-csharp">Type t = new Type();	// 或其他分配资源的方式
using (t) {
    // ... 
}
</code></pre>
</li>
<li>
<p>即把资源的声明和分配放在using之前</p>
</li>
<li>
<p>不推荐使用，因为和另一种形式相比，不能保证在使用using之前资源没有被释放，或者在using执行结束后资源被释放后继续使用资源</p>
</li>
</ul>
</li>
<li>
<p>using一般使用于一些如数量有限制或耗费系统资源的情况，如文件的读写、数据库的连接等</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 918.环形数组的最大和]]></title>
        <id>https://greydoveh.github.io/post/leetcode-918/</id>
        <link href="https://greydoveh.github.io/post/leetcode-918/">
        </link>
        <updated>2022-02-16T03:50:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="leetcode-918环形数组的最大和">LeetCode 918.环形数组的最大和</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">题目链接</a></p>
<h3 id="思路">思路</h3>
<p>思路和<a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53.最大子数组和</a>类似<br>
在原题基础上，先求中间一段最大子数组和ans1，容易知道ans1是<strong>不跨越原点的最大值</strong><br>
然后再求一个<strong>跨越原点的最大值</strong><br>
这个思路和上面的反过来，先求中间一段<strong>最小子数组和</strong>ans2，然后用<strong>总和减去该最小子数组和</strong>，得到的即是<strong>跨越两边的最大值</strong>sum[n] - ans2<br>
最后<strong>两者取最大值</strong>返回max(ans1, sum[n] - ans2);</p>
<blockquote>
<p>注意一个特殊情况，当整个数组全为负数的时候，最小子数组和为整个数组的和，会导致返回的值为0，此时取得是一个空的子数组，但是题目要求要的是一个<strong>非空</strong>子数组的和，所以要判断一下左右边界</p>
</blockquote>
<h3 id="代码">代码</h3>
<pre><code class="language-csharp">public class Solution {
    public int MaxSubarraySumCircular(int[] nums) {
        int[] sum = new int [nums.Length + 1];
        for (int i = 1; i &lt; sum.Length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
        int min = sum[0], ans1 = int.MinValue;
        for (int i = 1; i &lt; sum.Length; i++) {
            ans1 = Math.Max(ans1, sum[i] - min);
            min = Math.Min(sum[i], min);
        }
        int max = sum[0], ans2 = int.MaxValue, l = 0, r = 0, maxIndex = 0;
        for (int i = 1; i &lt; sum.Length; i++) {
            if (ans2 &gt; sum[i] - max) {
                r = i;
                l = maxIndex;
                ans2 = sum[i] - max;
            }
            if (sum[i] &gt; max) {
                max = sum[i];
                maxIndex = i;
            }
        }
        if (l == 0 &amp;&amp; r == sum.Length - 1) {
            return ans1;
        }
        return Math.Max(ans1, sum[sum.Length - 1] - ans2);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode.935 骑士拨号器]]></title>
        <id>https://greydoveh.github.io/post/leetcode-935/</id>
        <link href="https://greydoveh.github.io/post/leetcode-935/">
        </link>
        <updated>2022-02-12T14:44:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="leetcode935-骑士拨号器">LeetCode.935 骑士拨号器</h1>
<p><a href="https://leetcode-cn.com/problems/knight-dialer/">题目链接</a></p>
<h3 id="思路">思路</h3>
<blockquote>
<p>动态规划</p>
</blockquote>
<p>骑士每一步跳都会在号码后面增加一个新的数字，就会产生一个新的号码。<br>
由于跳的方式是固定的，所以从某个数字可以跳到的其他数字也是固定的。</p>
<blockquote>
<p>0 -&gt; 4, 6;<br>
1 -&gt; 6, 8;<br>
2 -&gt; 7, 9;<br>
3 -&gt; 4, 8;<br>
4 -&gt; 3, 9, 0;<br>
5 -&gt; null;<br>
6 -&gt; 1, 7, 0;<br>
7 -&gt; 2, 6;<br>
8 -&gt; 1, 3;<br>
9 -&gt; 2, 4;</p>
</blockquote>
<p>在这个基础上容易知道，要产生一个n位的号码，只需看第n-1位的数字是多少，然后根据这一位数字能够走到的位置k，得到可以得到k个新的号码。</p>
<p>所以，可以得到状态转移方程<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>−</mo><mo>&gt;</mo><mi>k</mi></mrow></msub><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n, k) = \sum_{j-&gt;k} f(n - 1, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18639799999999984em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">−</span><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span><br>
其中f(n, k)代表长度为n尾号为k的号码的个数，在长度为n−1和n之间，如果骑士能够从j跳到k，则能够为生成尾号为k的号码提供1点贡献；如果有m个尾号为j的骑士，则能为生成尾号为k的号码提供m点贡献；若有不同的号码都能到k，则它们都能提供对应的贡献。</p>
<p>举个例子，因为6能到达1, 7, 0三个点，所以通过16这个号码，可以产生161, 167, 160三个号码；同理，因为从0, 1, 7三个点可以到达6，所以XXX6可以由XX0, XX1, XX7三个号码产生。通过统计XX0, XX1, XX7的个数进行求和，则可以得到这么多个XXX6。如果对长度为nn所有尾号进行计数，则可以得到长度为nn的号码的个数。</p>
<h3 id="代码">代码</h3>
<pre><code class="language-csharp">public class Solution {
    const int MOD = (int)1e9 + 7;
    int[,] cnt;
    public int KnightDialer(int n) {
        cnt = new int[2, 10];
        int[][] list = new int[10][] {
            new int[2]{4, 6},
            new int[2]{6, 8},
            new int[2]{7, 9},
            new int[2]{4, 8},
            new int[3]{3, 9, 0},
            new int[0]{},
            new int[3]{1, 7, 0},
            new int[2]{2, 6},
            new int[2]{1, 3},
            new int[2]{2, 4},
        };
        for (int i = 0; i &lt; 10; i++) {
            cnt[0, i] = 1;
        }
        int pre = 0, now = 1;
        for (int i = 1; i &lt; n; i++) {
            for (int j = 0; j &lt; 10; j++) {
                cnt[now, j] = 0;
            }
            for (int j = 0; j &lt; 10; j++) {
                for (int k = 0; k &lt; list[j].Length; k++) {
                    cnt[now, list[j][k]] = ((cnt[now, list[j][k]] % MOD) + (cnt[pre, j] % MOD)) % MOD;
                }
            }
            (now, pre) = (pre, now);
        }
        long res = 0;
        for (int j = 0; j &lt; 10; j++) {
            res = ((res % MOD) + (cnt[pre, j] % MOD)) % MOD;
        }
        return (int)(res % MOD);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode.1001 网格照明 题解]]></title>
        <id>https://greydoveh.github.io/post/leetcode-1001/</id>
        <link href="https://greydoveh.github.io/post/leetcode-1001/">
        </link>
        <updated>2022-02-10T12:48:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="leetcode1001-网格照明">LeetCode.1001 网格照明</h1>
<p><a href="https://leetcode-cn.com/problems/grid-illumination/">题目链接</a></p>
<h3 id="思路">思路</h3>
<blockquote>
<p>哈希/字典</p>
</blockquote>
<p>对于每个灯，记录这个灯的位置，在x行y列，对行和列分别记录，并记录两条对角线的灯的个数<br>
对于每次查询，先看在这一行和这一列是否存在灯，然后查询对角线<br>
对每一行/列，只需检查这一行/列有无灯即可，这里即判断SortedSet/HashSet中是否有元素<br>
对于对角线，两条对角线的特点为和/差为定值，可以通过和差来判断该对角线上有无灯</p>
<p>删除时，对包括自身在内的周围9个位置检测是否有灯，对四个字典中的灯进行删除<br>
对于行/列，删除时只需删除对应的元素即可，只要插入时有判重就没有问题<br>
对于对角线处理可能有些麻烦，这里的处理方法是添加时不是判断是否有灯而是对对角线上的灯进行计数，而删除时是在删除行/列的基础上进行的，因为对行/列的字典可以检测到具体的位置，若检测到该位置有灯，则对其两条对角线上删除一个灯即可</p>
<h3 id="代码">代码</h3>
<pre><code class="language-csharp">public class Solution {
    public bool Judge(int x, int y, int n) {
        return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;
    }
    public int[] GridIllumination(int n, int[][] lamps, int[][] queries) {
        Dictionary&lt;int, SortedSet&lt;int&gt;&gt; onx = new Dictionary&lt;int, SortedSet&lt;int&gt;&gt;();
        Dictionary&lt;int, SortedSet&lt;int&gt;&gt; ony = new Dictionary&lt;int, SortedSet&lt;int&gt;&gt;();
        Dictionary&lt;int, int&gt; plus = new Dictionary&lt;int, int&gt;();
        Dictionary&lt;int, int&gt; sub = new Dictionary&lt;int, int&gt;(); 
        for (int i = 0; i &lt; lamps.Length; i++) {
            bool have = false;
            int x = lamps[i][0], y = lamps[i][1];
            if (!onx.ContainsKey(x)) {
                SortedSet&lt;int&gt; set = new SortedSet&lt;int&gt;();
                set.Add(y);
                onx.Add(x, set);
            } else {
                if (!onx[x].Contains(y)) {
                    onx[x].Add(y);
                } else {
                    have = true;
                }
            }
            if (!ony.ContainsKey(y)) {
                SortedSet&lt;int&gt; set = new SortedSet&lt;int&gt;();
                set.Add(x);
                ony.Add(y, set);
            } else {
                if (!ony[y].Contains(x)) {
                    ony[y].Add(x);
                } else {
                    have = true;
                }
            }
            if (plus.ContainsKey(x + y)) {
                if (!have)  plus[x + y]++;
            } else {
                plus.Add(x + y, 1);
            }
            if (sub.ContainsKey(x - y)) {
                if (!have)  sub[x - y]++;
            } else {
                sub.Add(x - y, 1);
            }
        }
        
        int[] ans = new int[queries.Length];
        for (int i = 0; i &lt; queries.Length; i++) {
            int x = queries[i][0], y = queries[i][1];
            ans[i] = 0;
            if (onx.ContainsKey(x) &amp;&amp; onx[x].Count != 0) {
                ans[i] = 1;
            } else if (ony.ContainsKey(y) &amp;&amp; ony[y].Count != 0) {
                ans[i] = 1;
            } else if (plus.ContainsKey(x + y) &amp;&amp; plus[x + y] != 0) {
                ans[i] = 1;
            } else if (sub.ContainsKey(x - y) &amp;&amp; sub[x - y] != 0) {
                ans [i] = 1;
            }

            for (int j = x - 1; j &lt;= x + 1; j++) {
                for (int k = y - 1; k &lt;= y + 1; k++) {
                    if (!judge(j, k, n))    continue;
                    if (onx.ContainsKey(j) &amp;&amp; onx[j].Contains(k)) {
                        onx[j].Remove(k);
                        if (onx[j].Count == 0) {
                            onx.Remove(j);
                        }
                        if (plus.ContainsKey(j + k)) {
                            plus[j + k]--;
                            if (plus[j + k] == 0) {
                                plus.Remove(j + k);
                            }
                        }
                        if (sub.ContainsKey(j - k)) {
                            sub[j - k]--;
                            if (sub[j - k] == 0) {
                                sub.Remove(j - k);
                            }
                        }
                    }
                    if (ony.ContainsKey(k) &amp;&amp; ony[k].Contains(j)) {
                        ony[k].Remove(j);
                        if (ony[k].Count == 0) {
                            ony.Remove(k);
                        }
                    }
                }
            }
        }
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>