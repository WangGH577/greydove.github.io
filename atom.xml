<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greydoveh.github.io</id>
    <title>鸽子屋</title>
    <updated>2022-05-15T12:51:00.612Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greydoveh.github.io"/>
    <link rel="self" href="https://greydoveh.github.io/atom.xml"/>
    <subtitle>咕咕咕</subtitle>
    <logo>https://greydoveh.github.io/images/avatar.png</logo>
    <icon>https://greydoveh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 鸽子屋</rights>
    <entry>
        <title type="html"><![CDATA[校赛A题 题解]]></title>
        <id>https://greydoveh.github.io/post/ACM-A/</id>
        <link href="https://greydoveh.github.io/post/ACM-A/">
        </link>
        <updated>2022-05-15T12:50:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="a-english-problem">A. English Problem</h1>
<h3 id="题目解释">题目解释</h3>
<p>既然是英文题那就简单解释一下题意好了。<br>
给你两个整数n和k，你要构造一个长度为N且每个数互不相同的数组，满足的条件如下：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2 \leq a_i \leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></li>
<li>所有元素的最小素因子的异或是一个小于等于k的素数</li>
</ol>
<h3 id="思路">思路</h3>
<p>难度定义是cf div2的A题（或者不超过B）</p>
<p>偶数的最小素因子一定是2</p>
<ol>
<li>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是奇数的情况，可以构造<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个偶数，他们的最小素因子的异或一定为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是偶数的情况，可以先构造<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个偶数（异或结果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），再构造两个异或起来是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的素数即可，如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>⊕</mo><mn>7</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">5 \oplus 7 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>17</mn><mo>⊕</mo><mn>19</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">17 \oplus 19 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ol>
<p><s>（所以对于正解来说k是没用的，题目只是限制大家的构造尽可能小）</s></p>
<h3 id="std">std</h3>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
const int MOD = 1e9 + 7;
int n, k;

int main() {
    int T = 1;  cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; n &gt;&gt; k;
        if (n &amp; 1) {
            for (int i = 1; i &lt;= n; i++) {
                cout &lt;&lt; 2 * i &lt;&lt; &quot; &quot;;
            }
        } else {
            for (int i = 1; i &lt;= n - 2; i++) {
                cout &lt;&lt; 2 * i &lt;&lt; &quot; &quot;;
            }
            cout &lt;&lt; &quot;5 7 &quot;;
        }   
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[校赛B题 题解]]></title>
        <id>https://greydoveh.github.io/post/ACM-B/</id>
        <link href="https://greydoveh.github.io/post/ACM-B/">
        </link>
        <updated>2022-05-15T12:49:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="b-辉哥的像素画">B. 辉哥的像素画</h1>
<h3 id="思路">思路</h3>
<p>问题可以转化为，给定一个三角形，判断某个点是否在三角形内。然后遍历每个点就好</p>
<p>有三种方法：</p>
<ol>
<li>向量叉积法：
<ul>
<li>主要利用向量叉积的方向性，如果一个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>在三角形<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>内部，那一定满足：</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow><mo>⃗</mo></mover><mo>∗</mo><mover accent="true"><mrow><mi>A</mi><mi>P</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{AB} * \vec{AP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>B</mi><mi>C</mi></mrow><mo>⃗</mo></mover><mo>∗</mo><mover accent="true"><mrow><mi>B</mi><mi>P</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{BC} * \vec{BP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>A</mi></mrow><mo>⃗</mo></mover><mo>∗</mo><mover accent="true"><mrow><mi>C</mi><mi>A</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{CA}*\vec{CA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9663299999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>三个向量同向（其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>指向量的叉积，可能有多种写法，注意<strong>方向性</strong>，自己比划一下）</li>
</ul>
</li>
<li>直线公式法：
<ul>
<li>叉积没学好的同学可以用直线公式法，这也是比赛中很多同学提交并且WA掉的方法，主要需要注意因为<strong>斜率可能不存在</strong>，而且可能产生浮点数导致精度爆炸，所以建议使用直线一般式，同时把分母约掉</li>
<li>具体的方法就是判断<strong>P、A在直线BC同侧</strong>，<strong>P、B在直线AC同侧</strong>，<strong>P、C在直线AB同侧</strong>，则说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>在三角形<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>内，只要有一个在异侧，说明在三角形外</li>
</ul>
</li>
<li>面积法：
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>P</mi><mi>A</mi><mi>B</mi></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mi>P</mi><mi>A</mi><mi>C</mi></mrow></msub><mo>+</mo><msub><mi>S</mi><mrow><mi>P</mi><mi>B</mi><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{ABC}=S_{PAB} + S_{PAC} + S_{PBC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>点在三角形<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>内部</li>
<li>需要注意的是如果使用面积可能会因为<strong>浮点数的精度</strong>问题导致WA，尤其是使用海伦公式计算面积要经过两次开根号；所以建议使用坐标计算面积（可以使用叉积算面积或者直接推导面积公式），由于坐标点都是整数，使用坐标计算面积时，除了最后有一个除以2不存在除法或根号等产生浮点数的运算，所以可以通过计算<strong>面积的2倍</strong>来完全避开浮点精度产生的问题，不使用二倍面积去判断也可以通过，稍微控制下精度就好。</li>
</ul>
</li>
</ol>
<h3 id="std">std</h3>
<h4 id="std1cpp向量叉乘法">std1.cpp(向量叉乘法)</h4>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
typedef long long llong;
const int MOD = 1e9 + 7;
const int N = 1e3 + 5;

struct Point {
    typedef Point Vector;
    int x, y, z;
    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) { }
    Vector operator - (const Point&amp; b) const {
        return Point(b.x - x, b.y - y, b.z - z);
    }
    Vector operator * (const Point&amp; b) const {  // 向量叉乘
        return Point(y * b.z - b.y * z, z * b.x - x * b.z, x * b.y - y * b.x);
    }
};
typedef Point Vector;

int n, k;
Point p[5];
Vector v[5];
int s[5];

bool judge(const Point&amp; pp) {
    for (int i = 0; i &lt; 3; i++) {
        s[i] = (v[i] * (pp - p[i])).z;
    }
    return (s[0] &gt;= 0 &amp;&amp; s[1] &gt;= 0 &amp;&amp; s[2] &gt;= 0) || (s[0] &lt;= 0 &amp;&amp; s[1] &lt;= 0 &amp;&amp; s[2] &lt;= 0);
}

int main() {
    int n;  cin &gt;&gt; n;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;
    }
    p[3] = p[0];    // 这里不写也可以，只是后面p[i+1]要写成p[(i+1)%3]
    for (int i = 0; i &lt; 3; i++) {
        v[i] = p[i + 1] - p[i];
    }
    for (int y = n - 1; y &gt;= 0; y--) {
        for (int x = 0; x &lt; n; x++) {
            if (judge(Point(x, y))) {
                cout &lt;&lt; &quot;*&quot;;
            } else {
                cout &lt;&lt; &quot;.&quot;;
            }
        }   cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="std2cpp直线公式法">std2.cpp(直线公式法)</h4>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
typedef long long llong;
const int MOD = 1e9 + 7;
const int N = 1e3 + 5;

struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) { }
};

struct Lines {
    int a, b, c;    // 直线一般式的三个参数ABC, Ax+By+C=0
    Lines(int a = 0, int b = 0, int c = 0) : a(a), b(b), c(c) { }
    Lines(const Point&amp; p1, const Point&amp; p2) {   // 通过p1和p2两点的直线方程，手算很容易算出来
        a = p1.y - p2.y;
        b = p2.x - p1.x;
        c = p1.x * p2.y - p1.y * p2.x;
    }
    int side(const Point&amp; p) const {    
        int t = a * p.x + b * p.y + c;
        return t &gt; 0 ? 1 : (t == 0 ? 0 : -1);
        // 这里返回符号而不是原值，避免后面乘法爆int
    }
};

int n, k;
Point p[5];
Lines l[5];

bool judge(const Point&amp; pp) {
    if (l[0].side(pp) * l[0].side(p[2]) &lt; 0)  return false;
    if (l[1].side(pp) * l[1].side(p[0]) &lt; 0)  return false;
    if (l[2].side(pp) * l[2].side(p[1]) &lt; 0)  return false;
    return true;
}

int main() {
    int n;  cin &gt;&gt; n;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;
    }
    p[3] = p[0];
    for (int i = 0; i &lt; 3; i++) {
        l[i] = Lines(p[i], p[i + 1]);
    }
    for (int y = n - 1; y &gt;= 0; y--) {
        for (int x = 0; x &lt; n; x++) {
            if (judge(Point(x, y))) {
                cout &lt;&lt; &quot;*&quot;;
            } else {
                cout &lt;&lt; &quot;.&quot;;
            }
        }   cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h4 id="std3cpp面积法">std3.cpp(面积法)</h4>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;
typedef long long llong;
const int MOD = 1e9 + 7;
const int N = 1e3 + 5;

struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) { }
};

int n, k;
Point p[5];

int getTwiceArea(Point a, Point b, Point c) {   // 二倍的面积，可以通过坐标直接算，也可以用叉积算
    return abs((a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x));
}

bool judge(const Point&amp; pp) {
    int ans1 = getTwiceArea(p[0], p[1], p[2]);
    int ans2 = 0;
    for (int i = 0; i &lt; 3; i++) {
        ans2 += getTwiceArea(pp, p[i], p[i + 1]);
    }
    return ans1 == ans2;
}

int main() {
    int n;  cin &gt;&gt; n;
    for (int i = 0; i &lt; 3; i++) {
        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;
    }
    p[3] = p[0];
    for (int y = n - 1; y &gt;= 0; y--) {
        for (int x = 0; x &lt; n; x++) {
            if (judge(Point(x, y))) {
                cout &lt;&lt; &quot;*&quot;;
            } else {
                cout &lt;&lt; &quot;.&quot;;
            }
        }   cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-2071 不相交子区间 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2071/</id>
        <link href="https://greydoveh.github.io/post/51nod-2071/">
        </link>
        <updated>2022-04-12T07:40:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2071-不相交子区间-题解">51Nod-2071 不相交子区间 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2071">不相交子区间</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点，求最后剩下几条线段</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>按照右端点排序，记录当前能到达的最远右端点</p>
<p>对于每条线段，如果左端点在最远右端点左边，则说明该线段需要被删掉</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n;
struct Node {
    int l, r;
    Node(int l = 0, int r = 0) : l(l), r(r) { }
    bool operator &lt; (Node ano) {
        return r &lt; ano.r;
    }
};

vector&lt;Node&gt; v;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if (l &gt; r)  swap(l ,r);
        v.emplace_back(Node(l, r));
    }
    sort(v.begin(), v.end());
    int r = -1000, ans = n;
    for (int i = 0; i &lt; n; i++) {
        if (v[i].l &lt; r) {
            ans--;
        } else {
            r = max(r, v[i].r);
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-1091 线段的重叠 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-1091/</id>
        <link href="https://greydoveh.github.io/post/51nod-1091/">
        </link>
        <updated>2022-04-12T07:35:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-1091-线段的重叠-题解">51Nod-1091 线段的重叠 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1091">线段的重叠</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给出N条线段的起点和终点，从中选出2条线段，这两条线段的重叠部分是最长的。输出这个最长的距离。</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>对这些线段优先按照左端点升序排序</p>
<p>枚举每条线段，记录枚举过的线段能到达的最远距离</p>
<p>对于每条线段，如果有重叠，计算重叠的长度最大值</p>
<p>重叠长度的计算方式为：max(最远右端点, 当前右端点)- 当前左断点</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n, m, x;

struct Node {
    llong l, r;
    Node(llong l = 0, llong r = 0) : l(l), r(r) { }
    bool operator &lt; (Node a) {
        if (l == a.l)   return r &lt; a.r;
        return l &lt; a.l;
    }
};
vector&lt;Node&gt; v;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        llong l, r; cin &gt;&gt; l &gt;&gt; r;
        v.emplace_back(Node(l, r));
    }
    sort(v.begin(), v.end());
    llong ans = 0, id = 0;
    for (int i = 1; i &lt; n; i++) {
        if (v[i].l &lt; v[id].r) {
            ans = max(ans, min(v[id].r, v[i].r) - max(v[id].l, v[i].l));
        }
        if (v[i].r &gt; v[id].r) {
            id = i;
        } 
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-1289 大鱼吃小鱼 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-1289/</id>
        <link href="https://greydoveh.github.io/post/51nod-1289/">
        </link>
        <updated>2022-04-12T07:24:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-1289-大鱼吃小鱼-题解">51Nod-1289 大鱼吃小鱼 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1289">大鱼吃小鱼</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>用栈去维护向右移动的鱼</p>
<p>从左到右遍历，如果碰到向左的鱼，则判断鱼的大小与栈顶元素的关系，</p>
<p>如果栈顶的鱼更大，则忽略这条鱼（被栈顶吃掉），否则栈顶的鱼被吃掉退栈</p>
<p>一直到栈为空或者栈顶鱼大于这条向左的鱼</p>
<p>如果栈为空，则这条鱼活了下来，左边的其他鱼都被吃掉了</p>
<p>否则栈中剩余的鱼存活，这条向左的鱼被吃掉</p>
<p>最后记录向左移动存活的鱼（栈为空时计数）和向右移动存活的鱼（遍历到最后栈中剩下的鱼）</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n;
int a[N], b[N];

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    }
    int ans = 0;
    stack&lt;int&gt; st;
    for (int i = 0; i &lt; n; i++) {
        if (b[i]) {
            st.push(i);
        } else {
            while (st.size() &amp;&amp; a[i] &gt; a[st.top()]) {
                st.pop();
            }
            if (st.empty()) {
                ans++;
            }
        }
    }
    ans += st.size();
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-2488 矩形并的面积 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2488/</id>
        <link href="https://greydoveh.github.io/post/51nod-2488/">
        </link>
        <updated>2022-04-12T07:05:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2488-矩形并的面积-题解">51Nod-2488 矩形并的面积 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2488">矩形并的面积</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给两个矩形，每条边分别和坐标轴平行，求两个矩形覆盖的总面积</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<blockquote>
<p>用左下和右上两个点来表示矩形</p>
<p>如果两个矩形分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b), (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(e, f), (g, h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，相交部分的矩形表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1), (x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>则</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>e</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>c</mi><mo separator="true">,</mo><mi>g</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mo>)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x_1 = max(a, e)\\
y_1 = max(b, f)\\
x_2 = min(c, g)\\
y_2 = min(d, h)\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 &lt; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_1 &lt; y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，说明两矩形确实有相交部分</p>
<p>求两个矩形面积之和然后减去相交的小矩形的面积即可</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
int n, m;
llong a, b, c, d;
llong e, f, g, h;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    cin &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h;
    llong ans = 0;
    ans += (c - a) * (d - b);
    ans += (g - e) * (h - f);
    llong x1 = max(a, e);
    llong y1 = max(b, f);
    llong x2 = min(c, g);
    llong y2 = min(d, h);
    if (x1 &lt; x2 &amp;&amp; y1 &lt; y2) { 
        ans -= (x2 - x1) * (y2 - y1);
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3045 Lcm与Gcd构造 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3045/</id>
        <link href="https://greydoveh.github.io/post/51nod-3045/">
        </link>
        <updated>2022-04-12T06:41:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3045-lcm与gcd构造-题解">51Nod-3045 Lcm与Gcd构造 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=3045">Lcm与Gcd构造</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>已知gcd(a,b)和lcm(a,b)，求满足条件的ab使得a+b最小</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">lcm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span></span></span></span>可以求得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a*b=gcd*lcm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span></span></span></span><br>
然后枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的因子分别作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，判断是否满足条件并求最小值<br>
实际复杂度过大，所以这里采用另外的方式<br>
令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mi>a</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x=\frac{a}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{b}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a + b = gcd * (x + y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(x, y) == 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x * y = \frac{a * b}{gcd * gcd} = \frac{lcm}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>只需要枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{lcm}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>因子即可</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong gcd, lcm;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    int T = 1;	cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; gcd &gt;&gt; lcm;
        llong t = lcm / gcd;
        llong ans = 0x7fffffffffffffff;
        for (llong i = 1; i &lt;= t / i; i++) {
            if (t % i == 0 &amp;&amp; __gcd(i, t / i) == 1) {
                ans = min(ans, gcd * (i + t / i));
            }
        }
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-2502、2658 最多分成多少块 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2502-2658/</id>
        <link href="https://greydoveh.github.io/post/51nod-2502-2658/">
        </link>
        <updated>2022-04-12T06:15:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2502-2658-最多分成多少块-题解">51Nod-2502、2658 最多分成多少块 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2502">最多分成多少块</a></p>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2658">最多分成多少块 V2</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给一个[0, n)的排列的数组，把这个数组分成若干块，对每块进行按升序排序，保证整个数组最后是升序的</p>
<p>问最多能分成几块</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>容易想到的是，如果最后的数组是有序的，首先0应该在第一组中，0前面的元素都要放在第一组，同时因为给出的是一个排列，所以前i个元素排好序后应该刚好是[0, i)，即第一组中的所有数字应该恰好是[0, i)的一个排列</p>
<p>所以长度为i的前缀分成第一组的充要条件是：<strong>这个前缀的最小值为0，最大值为i</strong></p>
<p>但是由于是一个排列，前i个元素中必定没有相等元素，前i个数的所以最大值为i时，最小值也一定为0</p>
<p>所以<strong>长度为i的前缀分成第一组</strong>的充要条件是：<strong>这个前缀的最大值为i</strong></p>
<p>然后再继续思考：</p>
<p>现在<strong>有两个满足条件的前缀，一个长度为a，一个长度为b（a&lt;b），那么他们可以被分成两组，第一组为[0,a)，第二组为[a,b)</strong></p>
<p>因为[0, a)排好后，[0,b)的前a个是不动的</p>
<p>遍历数组，如果前i个元素的最大值为i，则组数+1</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n, a[N];

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    llong mx = -1, ans = 0;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        mx = max(mx, a[i]);
        if (mx == i) {
            ans++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3234 小明爱配对 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3234/</id>
        <link href="https://greydoveh.github.io/post/51nod-3234/">
        </link>
        <updated>2022-04-09T10:55:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3234-小明爱配对-题解">51Nod-3234 小明爱配对 题解</h1>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=3234">小明爱配对</a></p>
<h3 id="题目大意">题目大意</h3>
<blockquote>
<p>给定一个序列，给序列中的人两两配对</p>
<ol>
<li>相邻男女可以配对</li>
<li>优先选择权值相差最小的一对，不止一对选择下标最小的一对</li>
<li>配对成功后从原序列中删除，原来不相邻的可以变成相邻</li>
<li>一直到无法配对为止</li>
</ol>
<p>按配对的先后顺序求所有的对</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<blockquote>
<p>使用堆去存储配对信息</p>
<p>对初始序列扫描一遍，把所有符合要求的对放入堆中</p>
<p>每次从堆中取出一个配对，并在原序列中删除，并把新的相邻可配对元素放入堆中</p>
<p>删除的复杂度较高，可以使用链表解决</p>
<p>也可以使用标记的方式，同时对每个元素分别记录左右位置信息，当删除配对时更新左右位置信息，将元素标记为删除，可以防止某个元素被重复使用</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int INF = 0x3f3f3f3f;
int n, m;
vector&lt;pair&lt;int, int&gt; &gt; ans;
vector&lt;pair&lt;int, int&gt; &gt; a;
bool vis[N];
int l[N], r[N];

struct Node {
    int l, r, sub;
    Node(int l = 0, int r = 0, int sub = 0) : l(l), r(r), sub(sub) { }
};

struct cmp {
    bool operator () (Node a, Node b){
        if (a.sub == b.sub) {
            if (a.l == b.l) {
                return a.r &gt; b.r;
            }
            return a.l &gt; b.l;
        }
        return a.sub &gt; b.sub;
    }
};

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        string s;   int x;
        cin &gt;&gt; s &gt;&gt; x;
        a.emplace_back(make_pair(s == &quot;B&quot;, x));
        l[i] = i - 1;   r[i] = i + 1;
    }
    r[n - 1] = -1;
    priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;
    for (int i = 1; i&lt; n; i++) {
        if (a[i - 1].first ^ a[i].first) {
            pq.push(Node(i - 1, i, abs(a[i - 1].second - a[i].second)));
        }
    }
    while (pq.size()) {
        auto x = pq.top();  pq.pop();
        if (vis[x.l] || vis[x.r]) continue;
        ans.emplace_back(make_pair(x.l, x.r));
        vis[x.l] = vis[x.r] = true;
        int ll = l[x.l], rr = r[x.r];
        if (~ll &amp;&amp; ~rr) {
            r[ll] = rr;
            l[rr] = ll;
            if (a[ll].first ^ a[rr].first) {
                pq.push(Node(ll, rr, abs(a[ll].second - a[rr].second)));
            }
        }
    }
    cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;
    for (auto x : ans) {
        cout &lt;&lt; x.first + 1 &lt;&lt; &quot; &quot; &lt;&lt; x.second + 1 &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3188 字符王国 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3188/</id>
        <link href="https://greydoveh.github.io/post/51nod-3188/">
        </link>
        <updated>2022-04-09T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3188-字符王国-题解">51Nod-3188 字符王国 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=3188">字符王国</a></p>
<h3 id="题目大意">题目大意</h3>
<blockquote>
<p>一个有向无环图，每个节点有一个字符</p>
<p>路径的枯燥度定义为：这条路径上字符出现次数最多的字符出现的次数</p>
<p>求最枯燥的路径的枯燥度</p>
</blockquote>
<h3 id="解题思路1">解题思路1</h3>
<blockquote>
<p>深搜+dp</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个节点出发的路径中，字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>出现的最多的次数</p>
<p>对所有入度为0的节点做一次dfs（从越早的节点出发结果可能会越大，所以起点只考虑入度为0的点）</p>
<p>对节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的每个子节点搜索完毕后，更新从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>节点出发的所有字符的出现次数</p>
<p>最后求一次最大值即可</p>
</blockquote>
<h3 id="ac代码1">AC代码1</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 3e5 + 5;
int n, m;
string s;
vector&lt;int&gt; mp[N];
int indeg[N];

int ans = 0;
int cnt[N]['z' + 10];
bool vis[N];

void dfs(int x) {
    if (vis[x]) return;
    vis[x] = true;
    for (int i = 0; i &lt; mp[x].size(); i++) {
        dfs(mp[x][i]);
        for (int j = 'a'; j &lt;= 'z'; j++) {
            cnt[x][j] = max(cnt[x][j], cnt[mp[x][i]][j]);
        }
    }
    cnt[x][s[x - 1]]++;
}
int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    while (m--) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        mp[u].emplace_back(v);
        indeg[v]++;
    }
    for (int i = 1; i &lt;= n; i++) {
        if (indeg[i] == 0) {
            dfs(i);
        }
    }
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 'a'; j &lt;= 'z'; j++) {
            ans = max(ans, cnt[i][j]);
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<h3 id="解题思路2">解题思路2</h3>
<blockquote>
<p>枚举每个字符，结果即为该字符出现最多的路径</p>
<p>建立超级源点和超级汇点，对每个字符跑一次最长路即可，最大的结果即为答案</p>
<p>如果一条边到达节点为该字符，该边权记录为1，否则为0</p>
</blockquote>
<h3 id="ac代码2">AC代码2</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 3e5 + 5;
const int INF = 0x3f3f3f3f;
int n, m;
string s;
vector&lt;int&gt; mp[N];
int indeg[N];
int outdeg[N];

int ans = 0;
int d[N];
struct cmp {
    bool operator() (int a, int b) {
        return d[a] &lt; d[b];
    }
};

int dijkstra(char ch) {
    memset(d, -1, sizeof(d));
    priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;
    q.push(0);
    d[0] = 0;
    while (q.size()) {
        auto x = q.top();   q.pop();
        for (int i = 0; i &lt; mp[x].size(); i++) {
            int to = mp[x][i];
            int dist = s[mp[x][i] - 1] == ch ? 1 : 0;
            if (d[to] &lt; d[x] + dist) {
                d[to] = d[x] + dist;
                q.push(to);
            }
        }
    }
    return d[n + 1];
}

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    while (m--) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        mp[u].emplace_back(v);
        indeg[v]++;
        outdeg[u]++;
    }
    for (int i = 1; i &lt;= n; i++) {
        if (indeg[i] == 0) {
            mp[0].emplace_back(i);
        }
        if (outdeg[i] == 0) {
            mp[i].emplace_back(n + 1);
        }
    }
    for (int i = 'a'; i &lt;= 'z'; i++) {
        ans = max(ans, dijkstra(i));
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>