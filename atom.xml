<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://greydoveh.github.io</id>
    <title>鸽子屋</title>
    <updated>2022-04-12T07:41:15.781Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://greydoveh.github.io"/>
    <link rel="self" href="https://greydoveh.github.io/atom.xml"/>
    <subtitle>咕咕咕</subtitle>
    <logo>https://greydoveh.github.io/images/avatar.png</logo>
    <icon>https://greydoveh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 鸽子屋</rights>
    <entry>
        <title type="html"><![CDATA[51Nod-2071 不相交子区间 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2071/</id>
        <link href="https://greydoveh.github.io/post/51nod-2071/">
        </link>
        <updated>2022-04-12T07:40:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2071-不相交子区间-题解">51Nod-2071 不相交子区间 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2071">不相交子区间</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点，求最后剩下几条线段</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>按照右端点排序，记录当前能到达的最远右端点</p>
<p>对于每条线段，如果左端点在最远右端点左边，则说明该线段需要被删掉</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n;
struct Node {
    int l, r;
    Node(int l = 0, int r = 0) : l(l), r(r) { }
    bool operator &lt; (Node ano) {
        return r &lt; ano.r;
    }
};

vector&lt;Node&gt; v;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        if (l &gt; r)  swap(l ,r);
        v.emplace_back(Node(l, r));
    }
    sort(v.begin(), v.end());
    int r = -1000, ans = n;
    for (int i = 0; i &lt; n; i++) {
        if (v[i].l &lt; r) {
            ans--;
        } else {
            r = max(r, v[i].r);
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-1091 线段的重叠 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-1091/</id>
        <link href="https://greydoveh.github.io/post/51nod-1091/">
        </link>
        <updated>2022-04-12T07:35:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-1091-线段的重叠-题解">51Nod-1091 线段的重叠 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1091">线段的重叠</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给出N条线段的起点和终点，从中选出2条线段，这两条线段的重叠部分是最长的。输出这个最长的距离。</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>对这些线段优先按照左端点升序排序</p>
<p>枚举每条线段，记录枚举过的线段能到达的最远距离</p>
<p>对于每条线段，如果有重叠，计算重叠的长度最大值</p>
<p>重叠长度的计算方式为：max(最远右端点, 当前右端点)- 当前左断点</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n, m, x;

struct Node {
    llong l, r;
    Node(llong l = 0, llong r = 0) : l(l), r(r) { }
    bool operator &lt; (Node a) {
        if (l == a.l)   return r &lt; a.r;
        return l &lt; a.l;
    }
};
vector&lt;Node&gt; v;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        llong l, r; cin &gt;&gt; l &gt;&gt; r;
        v.emplace_back(Node(l, r));
    }
    sort(v.begin(), v.end());
    llong ans = 0, id = 0;
    for (int i = 1; i &lt; n; i++) {
        if (v[i].l &lt; v[id].r) {
            ans = max(ans, min(v[id].r, v[i].r) - max(v[id].l, v[i].l));
        }
        if (v[i].r &gt; v[id].r) {
            id = i;
        } 
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-1289 大鱼吃小鱼 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-1289/</id>
        <link href="https://greydoveh.github.io/post/51nod-1289/">
        </link>
        <updated>2022-04-12T07:24:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-1289-大鱼吃小鱼-题解">51Nod-1289 大鱼吃小鱼 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=1289">大鱼吃小鱼</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>用栈去维护向右移动的鱼</p>
<p>从左到右遍历，如果碰到向左的鱼，则判断鱼的大小与栈顶元素的关系，</p>
<p>如果栈顶的鱼更大，则忽略这条鱼（被栈顶吃掉），否则栈顶的鱼被吃掉退栈</p>
<p>一直到栈为空或者栈顶鱼大于这条向左的鱼</p>
<p>如果栈为空，则这条鱼活了下来，左边的其他鱼都被吃掉了</p>
<p>否则栈中剩余的鱼存活，这条向左的鱼被吃掉</p>
<p>最后记录向左移动存活的鱼（栈为空时计数）和向右移动存活的鱼（遍历到最后栈中剩下的鱼）</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n;
int a[N], b[N];

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i] &gt;&gt; b[i];
    }
    int ans = 0;
    stack&lt;int&gt; st;
    for (int i = 0; i &lt; n; i++) {
        if (b[i]) {
            st.push(i);
        } else {
            while (st.size() &amp;&amp; a[i] &gt; a[st.top()]) {
                st.pop();
            }
            if (st.empty()) {
                ans++;
            }
        }
    }
    ans += st.size();
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-2488 矩形并的面积 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2488/</id>
        <link href="https://greydoveh.github.io/post/51nod-2488/">
        </link>
        <updated>2022-04-12T07:05:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2488-矩形并的面积-题解">51Nod-2488 矩形并的面积 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2488">矩形并的面积</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给两个矩形，每条边分别和坐标轴平行，求两个矩形覆盖的总面积</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<blockquote>
<p>用左下和右上两个点来表示矩形</p>
<p>如果两个矩形分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a, b), (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>g</mi><mo separator="true">,</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(e, f), (g, h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，相交部分的矩形表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1), (x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>则</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>e</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>c</mi><mo separator="true">,</mo><mi>g</mi><mo>)</mo><mspace linebreak="newline"></mspace><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mo>)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">x_1 = max(a, e)\\
y_1 = max(b, f)\\
x_2 = min(c, g)\\
y_2 = min(d, h)\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 &lt; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_1 &lt; y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，说明两矩形确实有相交部分</p>
<p>求两个矩形面积之和然后减去相交的小矩形的面积即可</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
int n, m;
llong a, b, c, d;
llong e, f, g, h;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    cin &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h;
    llong ans = 0;
    ans += (c - a) * (d - b);
    ans += (g - e) * (h - f);
    llong x1 = max(a, e);
    llong y1 = max(b, f);
    llong x2 = min(c, g);
    llong y2 = min(d, h);
    if (x1 &lt; x2 &amp;&amp; y1 &lt; y2) { 
        ans -= (x2 - x1) * (y2 - y1);
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3045 Lcm与Gcd构造 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3045/</id>
        <link href="https://greydoveh.github.io/post/51nod-3045/">
        </link>
        <updated>2022-04-12T06:41:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3045-lcm与gcd构造-题解">51Nod-3045 Lcm与Gcd构造 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=3045">Lcm与Gcd构造</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>已知gcd(a,b)和lcm(a,b)，求满足条件的ab使得a+b最小</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">lcm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span></span></span></span>可以求得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">a*b=gcd*lcm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span></span></span></span><br>
然后枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的因子分别作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，判断是否满足条件并求最小值<br>
实际复杂度过大，所以这里采用另外的方式<br>
令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mi>a</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x=\frac{a}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{b}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a + b = gcd * (x + y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(x, y) == 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x * y = \frac{a * b}{gcd * gcd} = \frac{lcm}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>只需要枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>l</mi><mi>c</mi><mi>m</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{lcm}{gcd}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>因子即可</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong gcd, lcm;

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    int T = 1;	cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; gcd &gt;&gt; lcm;
        llong t = lcm / gcd;
        llong ans = 0x7fffffffffffffff;
        for (llong i = 1; i &lt;= t / i; i++) {
            if (t % i == 0 &amp;&amp; __gcd(i, t / i) == 1) {
                ans = min(ans, gcd * (i + t / i));
            }
        }
        cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-2502、2658 最多分成多少块 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-2502-2658/</id>
        <link href="https://greydoveh.github.io/post/51nod-2502-2658/">
        </link>
        <updated>2022-04-12T06:15:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-2502-2658-最多分成多少块-题解">51Nod-2502、2658 最多分成多少块 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2502">最多分成多少块</a></p>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=2658">最多分成多少块 V2</a></p>
<h3 id="题目概述">题目概述</h3>
<blockquote>
<p>给一个[0, n)的排列的数组，把这个数组分成若干块，对每块进行按升序排序，保证整个数组最后是升序的</p>
<p>问最多能分成几块</p>
</blockquote>
<h3 id="思路分析">思路分析</h3>
<blockquote>
<p>容易想到的是，如果最后的数组是有序的，首先0应该在第一组中，0前面的元素都要放在第一组，同时因为给出的是一个排列，所以前i个元素排好序后应该刚好是[0, i)，即第一组中的所有数字应该恰好是[0, i)的一个排列</p>
<p>所以长度为i的前缀分成第一组的充要条件是：<strong>这个前缀的最小值为0，最大值为i</strong></p>
<p>但是由于是一个排列，前i个元素中必定没有相等元素，前i个数的所以最大值为i时，最小值也一定为0</p>
<p>所以<strong>长度为i的前缀分成第一组</strong>的充要条件是：<strong>这个前缀的最大值为i</strong></p>
<p>然后再继续思考：</p>
<p>现在<strong>有两个满足条件的前缀，一个长度为a，一个长度为b（a&lt;b），那么他们可以被分成两组，第一组为[0,a)，第二组为[a,b)</strong></p>
<p>因为[0, a)排好后，[0,b)的前a个是不动的</p>
<p>遍历数组，如果前i个元素的最大值为i，则组数+1</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
llong n, a[N];

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    llong mx = -1, ans = 0;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
        mx = max(mx, a[i]);
        if (mx == i) {
            ans++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3234 小明爱配对 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3234/</id>
        <link href="https://greydoveh.github.io/post/51nod-3234/">
        </link>
        <updated>2022-04-09T10:55:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3234-小明爱配对-题解">51Nod-3234 小明爱配对 题解</h1>
<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=3234">小明爱配对</a></p>
<h3 id="题目大意">题目大意</h3>
<blockquote>
<p>给定一个序列，给序列中的人两两配对</p>
<ol>
<li>相邻男女可以配对</li>
<li>优先选择权值相差最小的一对，不止一对选择下标最小的一对</li>
<li>配对成功后从原序列中删除，原来不相邻的可以变成相邻</li>
<li>一直到无法配对为止</li>
</ol>
<p>按配对的先后顺序求所有的对</p>
</blockquote>
<h3 id="解题思路">解题思路</h3>
<blockquote>
<p>使用堆去存储配对信息</p>
<p>对初始序列扫描一遍，把所有符合要求的对放入堆中</p>
<p>每次从堆中取出一个配对，并在原序列中删除，并把新的相邻可配对元素放入堆中</p>
<p>删除的复杂度较高，可以使用链表解决</p>
<p>也可以使用标记的方式，同时对每个元素分别记录左右位置信息，当删除配对时更新左右位置信息，将元素标记为删除，可以防止某个元素被重复使用</p>
</blockquote>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 2e5 + 5;
const int INF = 0x3f3f3f3f;
int n, m;
vector&lt;pair&lt;int, int&gt; &gt; ans;
vector&lt;pair&lt;int, int&gt; &gt; a;
bool vis[N];
int l[N], r[N];

struct Node {
    int l, r, sub;
    Node(int l = 0, int r = 0, int sub = 0) : l(l), r(r), sub(sub) { }
};

struct cmp {
    bool operator () (Node a, Node b){
        if (a.sub == b.sub) {
            if (a.l == b.l) {
                return a.r &gt; b.r;
            }
            return a.l &gt; b.l;
        }
        return a.sub &gt; b.sub;
    }
};

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        string s;   int x;
        cin &gt;&gt; s &gt;&gt; x;
        a.emplace_back(make_pair(s == &quot;B&quot;, x));
        l[i] = i - 1;   r[i] = i + 1;
    }
    r[n - 1] = -1;
    priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;
    for (int i = 1; i&lt; n; i++) {
        if (a[i - 1].first ^ a[i].first) {
            pq.push(Node(i - 1, i, abs(a[i - 1].second - a[i].second)));
        }
    }
    while (pq.size()) {
        auto x = pq.top();  pq.pop();
        if (vis[x.l] || vis[x.r]) continue;
        ans.emplace_back(make_pair(x.l, x.r));
        vis[x.l] = vis[x.r] = true;
        int ll = l[x.l], rr = r[x.r];
        if (~ll &amp;&amp; ~rr) {
            r[ll] = rr;
            l[rr] = ll;
            if (a[ll].first ^ a[rr].first) {
                pq.push(Node(ll, rr, abs(a[ll].second - a[rr].second)));
            }
        }
    }
    cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;
    for (auto x : ans) {
        cout &lt;&lt; x.first + 1 &lt;&lt; &quot; &quot; &lt;&lt; x.second + 1 &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[51Nod-3188 字符王国 题解]]></title>
        <id>https://greydoveh.github.io/post/51nod-3188/</id>
        <link href="https://greydoveh.github.io/post/51nod-3188/">
        </link>
        <updated>2022-04-09T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="51nod-3188-字符王国-题解">51Nod-3188 字符王国 题解</h1>
<p><a href="https://www.51nod.com/Challenge/Problem.html#problemId=3188">字符王国</a></p>
<h3 id="题目大意">题目大意</h3>
<blockquote>
<p>一个有向无环图，每个节点有一个字符</p>
<p>路径的枯燥度定义为：这条路径上字符出现次数最多的字符出现的次数</p>
<p>求最枯燥的路径的枯燥度</p>
</blockquote>
<h3 id="解题思路1">解题思路1</h3>
<blockquote>
<p>深搜+dp</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个节点出发的路径中，字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>出现的最多的次数</p>
<p>对所有入度为0的节点做一次dfs（从越早的节点出发结果可能会越大，所以起点只考虑入度为0的点）</p>
<p>对节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的每个子节点搜索完毕后，更新从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>节点出发的所有字符的出现次数</p>
<p>最后求一次最大值即可</p>
</blockquote>
<h3 id="ac代码1">AC代码1</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 3e5 + 5;
int n, m;
string s;
vector&lt;int&gt; mp[N];
int indeg[N];

int ans = 0;
int cnt[N]['z' + 10];
bool vis[N];

void dfs(int x) {
    if (vis[x]) return;
    vis[x] = true;
    for (int i = 0; i &lt; mp[x].size(); i++) {
        dfs(mp[x][i]);
        for (int j = 'a'; j &lt;= 'z'; j++) {
            cnt[x][j] = max(cnt[x][j], cnt[mp[x][i]][j]);
        }
    }
    cnt[x][s[x - 1]]++;
}
int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    while (m--) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        mp[u].emplace_back(v);
        indeg[v]++;
    }
    for (int i = 1; i &lt;= n; i++) {
        if (indeg[i] == 0) {
            dfs(i);
        }
    }
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 'a'; j &lt;= 'z'; j++) {
            ans = max(ans, cnt[i][j]);
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<h3 id="解题思路2">解题思路2</h3>
<blockquote>
<p>枚举每个字符，结果即为该字符出现最多的路径</p>
<p>建立超级源点和超级汇点，对每个字符跑一次最长路即可，最大的结果即为答案</p>
<p>如果一条边到达节点为该字符，该边权记录为1，否则为0</p>
</blockquote>
<h3 id="ac代码2">AC代码2</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long llong;
const int N = 3e5 + 5;
const int INF = 0x3f3f3f3f;
int n, m;
string s;
vector&lt;int&gt; mp[N];
int indeg[N];
int outdeg[N];

int ans = 0;
int d[N];
struct cmp {
    bool operator() (int a, int b) {
        return d[a] &lt; d[b];
    }
};

int dijkstra(char ch) {
    memset(d, -1, sizeof(d));
    priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;
    q.push(0);
    d[0] = 0;
    while (q.size()) {
        auto x = q.top();   q.pop();
        for (int i = 0; i &lt; mp[x].size(); i++) {
            int to = mp[x][i];
            int dist = s[mp[x][i] - 1] == ch ? 1 : 0;
            if (d[to] &lt; d[x] + dist) {
                d[to] = d[x] + dist;
                q.push(to);
            }
        }
    }
    return d[n + 1];
}

int main() {
    #ifdef LOCAL
        freopen(&quot;D:/Code/ACM/in.in&quot;, &quot;r&quot;, stdin);
        freopen(&quot;D:/Code/ACM/out.out&quot;, &quot;w&quot;, stdout);
    #endif
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    while (m--) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        mp[u].emplace_back(v);
        indeg[v]++;
        outdeg[u]++;
    }
    for (int i = 1; i &lt;= n; i++) {
        if (indeg[i] == 0) {
            mp[0].emplace_back(i);
        }
        if (outdeg[i] == 0) {
            mp[i].emplace_back(n + 1);
        }
    }
    for (int i = 'a'; i &lt;= 'z'; i++) {
        ans = max(ans, dijkstra(i));
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#学习笔记合集]]></title>
        <id>https://greydoveh.github.io/post/CS-Learning/</id>
        <link href="https://greydoveh.github.io/post/CS-Learning/">
        </link>
        <updated>2022-03-27T05:08:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c学习笔记-目录">C#学习笔记 - 目录</h1>
<div class="archives-container">
<article class="post">
<a href = "https://greydoveh.github.io/post/CS-Enum/">
<h2 class="post-title">枚举</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Array/">
<h2 class="post-title">数组</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Delegate-Lambda-Event/">
<h2 class="post-title">委托、匿名方法、事件</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Interface/">
<h2 class="post-title">接口</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Convert/">
<h2 class="post-title">转换</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Generic/">
<h2 class="post-title">泛型</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-ENumerator-Iterator/">
<h2 class="post-title">枚举器和迭代器</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-DLL-EXE-Namespace/">
<h2 class="post-title">命名空间和程序集</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Preprocess/">
<h2 class="post-title">预处理指令</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-Reflection-Attribute/">
<h2 class="post-title">反射和特性</h2>
</a>
<a href = "https://greydoveh.github.io/post/CS-sth/">
<h2 class="post-title">杂</h2>
</a>
</article>
</div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 918.环形数组的最大和]]></title>
        <id>https://greydoveh.github.io/post/leetcode-918/</id>
        <link href="https://greydoveh.github.io/post/leetcode-918/">
        </link>
        <updated>2022-02-16T03:50:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="leetcode-918环形数组的最大和">LeetCode 918.环形数组的最大和</h1>
<p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">题目链接</a></p>
<h3 id="思路">思路</h3>
<p>思路和<a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53.最大子数组和</a>类似<br>
在原题基础上，先求中间一段最大子数组和ans1，容易知道ans1是<strong>不跨越原点的最大值</strong><br>
然后再求一个<strong>跨越原点的最大值</strong><br>
这个思路和上面的反过来，先求中间一段<strong>最小子数组和</strong>ans2，然后用<strong>总和减去该最小子数组和</strong>，得到的即是<strong>跨越两边的最大值</strong>sum[n] - ans2<br>
最后<strong>两者取最大值</strong>返回max(ans1, sum[n] - ans2);</p>
<blockquote>
<p>注意一个特殊情况，当整个数组全为负数的时候，最小子数组和为整个数组的和，会导致返回的值为0，此时取得是一个空的子数组，但是题目要求要的是一个<strong>非空</strong>子数组的和，所以要判断一下左右边界</p>
</blockquote>
<h3 id="代码">代码</h3>
<pre><code class="language-csharp">public class Solution {
    public int MaxSubarraySumCircular(int[] nums) {
        int[] sum = new int [nums.Length + 1];
        for (int i = 1; i &lt; sum.Length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
        int min = sum[0], ans1 = int.MinValue;
        for (int i = 1; i &lt; sum.Length; i++) {
            ans1 = Math.Max(ans1, sum[i] - min);
            min = Math.Min(sum[i], min);
        }
        int max = sum[0], ans2 = int.MaxValue, l = 0, r = 0, maxIndex = 0;
        for (int i = 1; i &lt; sum.Length; i++) {
            if (ans2 &gt; sum[i] - max) {
                r = i;
                l = maxIndex;
                ans2 = sum[i] - max;
            }
            if (sum[i] &gt; max) {
                max = sum[i];
                maxIndex = i;
            }
        }
        if (l == 0 &amp;&amp; r == sum.Length - 1) {
            return ans1;
        }
        return Math.Max(ans1, sum[sum.Length - 1] - ans2);
    }
}
</code></pre>
]]></content>
    </entry>
</feed>